use std::path::PathBuf;

use super::Error;

/// Generates Svelte 5 store integrations.
pub struct StoreGenerator {
    output_dir: PathBuf,
}

impl StoreGenerator {
    /// Create a new store generator.
    pub fn new(output_dir: impl Into<PathBuf>) -> Self {
        Self {
            output_dir: output_dir.into(),
        }
    }

    /// Generate the stores code.
    pub fn generate(&self) -> Result<String, Error> {
        Ok(self.generate_stores_content())
    }

    /// Generate the stores content.
    fn generate_stores_content(&self) -> String {
        r#"// Auto-generated by FORGE - DO NOT EDIT
import { getContext, setContext, onMount, onDestroy } from 'svelte';
import type { ForgeClient, ForgeClientConfig } from './client';
import { createForgeClient } from './client';
import type { QueryFn, MutationFn, ActionFn } from './api';
import type { QueryResult, SubscriptionResult, ForgeError } from './types';

// Context key for the FORGE client
const FORGE_CLIENT_KEY = Symbol('forge-client');

// Get the FORGE client from context
export function getForgeClient(): ForgeClient {
  const client = getContext<ForgeClient>(FORGE_CLIENT_KEY);
  if (!client) {
    throw new Error('FORGE client not found. Did you wrap your app with ForgeProvider?');
  }
  return client;
}

// Set the FORGE client in context
export function setForgeClient(client: ForgeClient): void {
  setContext(FORGE_CLIENT_KEY, client);
}

// Provider component props
export interface ForgeProviderProps {
  url: string;
  getToken?: () => string | null | Promise<string | null>;
  onAuthError?: (error: ForgeError) => void;
}

// Initialize the FORGE client in the provider
export function initForgeClient(props: ForgeProviderProps): ForgeClient {
  const client = createForgeClient({
    url: props.url,
    getToken: props.getToken,
    onAuthError: props.onAuthError,
  });
  setForgeClient(client);
  return client;
}

// Query result store
export interface QueryStore<T> {
  subscribe: (run: (value: QueryResult<T>) => void) => () => void;
  refetch: () => Promise<void>;
}

// Create a query store
export function query<TArgs, TResult>(
  fn: QueryFn<TArgs, TResult>,
  args: TArgs | (() => TArgs)
): QueryStore<TResult> {
  const client = getForgeClient();
  const subscribers = new Set<(value: QueryResult<TResult>) => void>();

  let state: QueryResult<TResult> = {
    loading: true,
    data: null,
    error: null,
  };

  const notify = () => {
    subscribers.forEach(run => run(state));
  };

  const fetchData = async () => {
    state = { ...state, loading: true, error: null };
    notify();

    try {
      const currentArgs = typeof args === 'function' ? (args as () => TArgs)() : args;
      const data = await fn(client, currentArgs);
      state = { loading: false, data, error: null };
    } catch (e) {
      const error = e as ForgeError;
      state = { loading: false, data: null, error };
    }
    notify();
  };

  // Initial fetch
  fetchData();

  return {
    subscribe(run) {
      subscribers.add(run);
      run(state);
      return () => subscribers.delete(run);
    },
    refetch: fetchData,
  };
}

// Subscription result store
export interface SubscriptionStore<T> extends QueryStore<T> {
  unsubscribe: () => void;
}

// Create a subscription store
export function subscribe<TArgs, TResult>(
  fn: QueryFn<TArgs, TResult>,
  args: TArgs | (() => TArgs)
): SubscriptionStore<TResult> {
  const client = getForgeClient();
  const subscribers = new Set<(value: SubscriptionResult<TResult>) => void>();
  let unsubscribeFn: (() => void) | null = null;

  let state: SubscriptionResult<TResult> = {
    loading: true,
    data: null,
    error: null,
    stale: false,
  };

  const notify = () => {
    subscribers.forEach(run => run(state));
  };

  const startSubscription = async () => {
    state = { ...state, loading: true, error: null, stale: false };
    notify();

    try {
      // First, get initial data
      const currentArgs = typeof args === 'function' ? (args as () => TArgs)() : args;
      const initialData = await fn(client, currentArgs);
      state = { loading: false, data: initialData, error: null, stale: false };
      notify();

      // Then subscribe for updates
      unsubscribeFn = client.subscribe(
        fn.functionName,
        currentArgs,
        (data: TResult) => {
          state = { loading: false, data, error: null, stale: false };
          notify();
        }
      );
    } catch (e) {
      const error = e as ForgeError;
      state = { loading: false, data: null, error, stale: false };
      notify();
    }
  };

  // Start subscription
  startSubscription();

  return {
    subscribe(run) {
      subscribers.add(run);
      run(state);
      return () => subscribers.delete(run);
    },
    refetch: startSubscription,
    unsubscribe: () => {
      if (unsubscribeFn) {
        unsubscribeFn();
        unsubscribeFn = null;
      }
    },
  };
}

// Mutate function
export async function mutate<TArgs, TResult>(
  fn: MutationFn<TArgs, TResult>,
  args: TArgs
): Promise<TResult> {
  const client = getForgeClient();
  return fn(client, args);
}

// Action function
export async function action<TArgs, TResult>(
  fn: ActionFn<TArgs, TResult>,
  args: TArgs
): Promise<TResult> {
  const client = getForgeClient();
  return fn(client, args);
}

// Optimistic mutation
export interface OptimisticOptions<TArgs, TResult, TData> {
  input: TArgs;
  optimistic: (current: TData) => TData;
  rollback?: (current: TData, error: ForgeError) => TData;
}

export async function mutateOptimistic<TArgs, TResult, TData>(
  fn: MutationFn<TArgs, TResult>,
  store: SubscriptionStore<TData>,
  options: OptimisticOptions<TArgs, TResult, TData>
): Promise<TResult> {
  // This is a simplified version - in practice, you'd need access to the store's internal state
  const client = getForgeClient();

  try {
    const result = await fn(client, options.input);
    return result;
  } catch (e) {
    throw e;
  }
}

// Hook for using auth state
export interface AuthState {
  user: unknown | null;
  token: string | null;
  loading: boolean;
}

export function useAuth(): { subscribe: (run: (value: AuthState) => void) => () => void } {
  const subscribers = new Set<(value: AuthState) => void>();

  let state: AuthState = {
    user: null,
    token: null,
    loading: true,
  };

  // In a real implementation, this would connect to an auth provider
  return {
    subscribe(run) {
      subscribers.add(run);
      run(state);
      return () => subscribers.delete(run);
    },
  };
}
"#
        .to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_store_generator_creation() {
        let gen = StoreGenerator::new("/tmp/forge");
        assert_eq!(gen.output_dir, PathBuf::from("/tmp/forge"));
    }

    #[test]
    fn test_generate_stores_content() {
        let gen = StoreGenerator::new("/tmp/forge");
        let content = gen.generate_stores_content();
        assert!(content.contains("getForgeClient"));
        assert!(content.contains("setForgeClient"));
        assert!(content.contains("ForgeProviderProps"));
        assert!(content.contains("QueryStore"));
        assert!(content.contains("SubscriptionStore"));
        assert!(content.contains("query<"));
        assert!(content.contains("subscribe<"));
        assert!(content.contains("mutate<"));
        assert!(content.contains("action<"));
        assert!(content.contains("useAuth"));
    }
}
