use std::path::PathBuf;

use forge_core::schema::SchemaRegistry;

use super::Error;

/// Generates TypeScript API bindings.
pub struct ApiGenerator {
    #[allow(dead_code)]
    output_dir: PathBuf,
}

impl ApiGenerator {
    /// Create a new API generator.
    pub fn new(output_dir: impl Into<PathBuf>) -> Self {
        Self {
            output_dir: output_dir.into(),
        }
    }

    /// Generate API bindings from the schema registry.
    pub fn generate(&self, _registry: &SchemaRegistry) -> Result<String, Error> {
        Ok(self.generate_api_content())
    }

    /// Generate the API content.
    fn generate_api_content(&self) -> String {
        r#"// Auto-generated by FORGE - DO NOT EDIT
import type { ForgeClient } from './client';

// Query function type
export interface QueryFn<TArgs, TResult> {
  (client: ForgeClient, args: TArgs): Promise<TResult>;
  functionName: string;
  functionType: 'query';
}

// Mutation function type
export interface MutationFn<TArgs, TResult> {
  (client: ForgeClient, args: TArgs): Promise<TResult>;
  functionName: string;
  functionType: 'mutation';
}

// Action function type
export interface ActionFn<TArgs, TResult> {
  (client: ForgeClient, args: TArgs): Promise<TResult>;
  functionName: string;
  functionType: 'action';
}

// Create a query function binding
export function createQuery<TArgs, TResult>(
  name: string
): QueryFn<TArgs, TResult> {
  const fn = async (client: ForgeClient, args: TArgs): Promise<TResult> => {
    return client.call(name, args);
  };
  (fn as QueryFn<TArgs, TResult>).functionName = name;
  (fn as QueryFn<TArgs, TResult>).functionType = 'query';
  return fn as QueryFn<TArgs, TResult>;
}

// Create a mutation function binding
export function createMutation<TArgs, TResult>(
  name: string
): MutationFn<TArgs, TResult> {
  const fn = async (client: ForgeClient, args: TArgs): Promise<TResult> => {
    return client.call(name, args);
  };
  (fn as MutationFn<TArgs, TResult>).functionName = name;
  (fn as MutationFn<TArgs, TResult>).functionType = 'mutation';
  return fn as MutationFn<TArgs, TResult>;
}

// Create an action function binding
export function createAction<TArgs, TResult>(
  name: string
): ActionFn<TArgs, TResult> {
  const fn = async (client: ForgeClient, args: TArgs): Promise<TResult> => {
    return client.call(name, args);
  };
  (fn as ActionFn<TArgs, TResult>).functionName = name;
  (fn as ActionFn<TArgs, TResult>).functionType = 'action';
  return fn as ActionFn<TArgs, TResult>;
}

// Example generated bindings (these would be generated from Rust functions)
/*
import type { Project, CreateProjectInput } from './types';

export const getProjects = createQuery<{ userId: string }, Project[]>('get_projects');
export const getProject = createQuery<{ id: string }, Project>('get_project');
export const createProject = createMutation<CreateProjectInput, Project>('create_project');
export const updateProject = createMutation<{ id: string; name?: string }, Project>('update_project');
export const deleteProject = createMutation<{ id: string }, void>('delete_project');
*/
"#
        .to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_api_generator_creation() {
        let gen = ApiGenerator::new("/tmp/forge");
        assert_eq!(gen.output_dir, PathBuf::from("/tmp/forge"));
    }

    #[test]
    fn test_generate_api_content() {
        let gen = ApiGenerator::new("/tmp/forge");
        let content = gen.generate_api_content();
        assert!(content.contains("QueryFn"));
        assert!(content.contains("MutationFn"));
        assert!(content.contains("ActionFn"));
        assert!(content.contains("createQuery"));
        assert!(content.contains("createMutation"));
        assert!(content.contains("createAction"));
    }
}
