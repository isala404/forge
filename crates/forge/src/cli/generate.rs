use anyhow::Result;
use clap::Parser;
use console::style;
use indicatif::{ProgressBar, ProgressStyle};
use std::fs;
use std::path::Path;
use std::time::Duration;

/// Generate TypeScript client code.
#[derive(Parser)]
pub struct GenerateCommand {
    /// Force regeneration even if files exist.
    #[arg(long)]
    pub force: bool,

    /// Output directory (defaults to frontend/src/lib/forge).
    #[arg(short, long)]
    pub output: Option<String>,

    /// Source directory to scan for models (defaults to src).
    #[arg(short, long)]
    pub src: Option<String>,
}

impl GenerateCommand {
    /// Execute the generate command.
    pub async fn execute(self) -> Result<()> {
        let output_dir = self
            .output
            .unwrap_or_else(|| "frontend/src/lib/forge".to_string());
        let output_path = Path::new(&output_dir);

        let src_dir = self.src.unwrap_or_else(|| "src".to_string());
        let src_path = Path::new(&src_dir);

        // Show progress
        let pb = ProgressBar::new(5);
        pb.set_style(
            ProgressStyle::default_bar()
                .template("{spinner:.green} {msg}")
                .unwrap(),
        );
        pb.enable_steady_tick(Duration::from_millis(100));

        // Parse source files
        pb.set_message("Scanning Rust source files...");
        let registry = if src_path.exists() {
            forge_codegen::parse_project(src_path)?
        } else {
            pb.set_message("No src directory found, using defaults...");
            forge_core::schema::SchemaRegistry::new()
        };
        pb.inc(1);

        // Check if we have any schema definitions
        let has_schema = !registry.all_tables().is_empty() || !registry.all_enums().is_empty();

        if has_schema {
            // Use forge_codegen to generate TypeScript
            pb.set_message("Generating TypeScript from schema...");
            let generator = forge_codegen::TypeScriptGenerator::new(&output_dir);
            generator.generate(&registry)?;
            pb.inc(4);
        } else {
            // Fall back to default templates if no schema found
            pb.set_message("No schema found, generating defaults...");

            // Create output directory if it doesn't exist
            if !output_path.exists() {
                fs::create_dir_all(output_path)?;
            }

            // Generate default files
            pb.set_message("Generating types...");
            generate_types(output_path, self.force)?;
            pb.inc(1);

            pb.set_message("Generating API bindings...");
            generate_api(output_path, self.force)?;
            pb.inc(1);

            pb.set_message("Generating stores...");
            generate_stores(output_path, self.force)?;
            pb.inc(1);

            pb.set_message("Generating index...");
            generate_index(output_path)?;
            pb.inc(1);
        }

        pb.finish_with_message("Done!");

        println!();
        if has_schema {
            let table_count = registry.all_tables().len();
            let enum_count = registry.all_enums().len();
            println!(
                "{} Generated TypeScript from {} models and {} enums",
                style("âœ…").green(),
                style(table_count).cyan(),
                style(enum_count).cyan()
            );
        }
        println!(
            "{} Output directory: {}",
            style("ðŸ“").dim(),
            style(&output_dir).cyan()
        );
        println!();

        Ok(())
    }
}

/// Generate types.ts from schema.
fn generate_types(output_dir: &Path, force: bool) -> Result<()> {
    let file_path = output_dir.join("types.ts");
    if file_path.exists() && !force {
        return Ok(());
    }

    // In a real implementation, this would use forge_codegen::TypeGenerator
    // and read the actual schema from the project
    let content = r#"// Auto-generated by FORGE - DO NOT EDIT

// Model types will be generated here based on your Rust schema
// Run `forge generate` after adding or modifying models

export interface User {
  id: string;
  email: string;
  name: string;
  createdAt: Date;
  updatedAt: Date;
}

// Common types
export interface ForgeError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
}

export interface QueryResult<T> {
  loading: boolean;
  data: T | null;
  error: ForgeError | null;
}

export interface SubscriptionResult<T> extends QueryResult<T> {
  stale: boolean;
}

export interface Paginated<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}
"#;

    fs::write(file_path, content)?;
    Ok(())
}

/// Generate api.ts with function bindings.
fn generate_api(output_dir: &Path, force: bool) -> Result<()> {
    let file_path = output_dir.join("api.ts");
    if file_path.exists() && !force {
        return Ok(());
    }

    // In a real implementation, this would scan the functions directory
    // and generate bindings for each function
    let content = r#"// Auto-generated by FORGE - DO NOT EDIT

import type { ForgeClient } from './client';
import type { User } from './types';

// Query function type
interface QueryFn<TArgs, TResult> {
  (client: ForgeClient, args: TArgs): Promise<TResult>;
  functionName: string;
  functionType: 'query';
}

// Mutation function type
interface MutationFn<TArgs, TResult> {
  (client: ForgeClient, args: TArgs): Promise<TResult>;
  functionName: string;
  functionType: 'mutation';
}

// Helper to create query functions
function createQuery<TArgs, TResult>(name: string): QueryFn<TArgs, TResult> {
  const fn = async (client: ForgeClient, args: TArgs): Promise<TResult> => {
    return client.call(name, args);
  };
  (fn as QueryFn<TArgs, TResult>).functionName = name;
  (fn as QueryFn<TArgs, TResult>).functionType = 'query';
  return fn as QueryFn<TArgs, TResult>;
}

// Helper to create mutation functions
function createMutation<TArgs, TResult>(name: string): MutationFn<TArgs, TResult> {
  const fn = async (client: ForgeClient, args: TArgs): Promise<TResult> => {
    return client.call(name, args);
  };
  (fn as MutationFn<TArgs, TResult>).functionName = name;
  (fn as MutationFn<TArgs, TResult>).functionType = 'mutation';
  return fn as MutationFn<TArgs, TResult>;
}

// Generated function bindings
export const getUsers = createQuery<{}, User[]>('get_users');
export const getUser = createQuery<{ id: string }, User | null>('get_user');
export const createUser = createMutation<{ email: string; name: string }, User>('create_user');
"#;

    fs::write(file_path, content)?;
    Ok(())
}

/// Generate stores.ts for Svelte integration.
fn generate_stores(output_dir: &Path, force: bool) -> Result<()> {
    let file_path = output_dir.join("stores.ts");
    if file_path.exists() && !force {
        return Ok(());
    }

    let content = r#"// Auto-generated by FORGE - DO NOT EDIT

// Re-export from @forge/svelte
export { query, subscribe, mutate, action, mutateOptimistic } from '@forge/svelte';
export type { QueryStore, SubscriptionStore } from '@forge/svelte';
"#;

    fs::write(file_path, content)?;
    Ok(())
}

/// Generate client.ts.
fn generate_client(output_dir: &Path) -> Result<()> {
    let file_path = output_dir.join("client.ts");

    let content = r#"// Auto-generated by FORGE - DO NOT EDIT

// Re-export from @forge/svelte
export { ForgeClient, ForgeClientError, createForgeClient } from '@forge/svelte';
export type { ForgeClientConfig } from '@forge/svelte';
"#;

    fs::write(file_path, content)?;
    Ok(())
}

/// Generate index.ts.
fn generate_index(output_dir: &Path) -> Result<()> {
    let file_path = output_dir.join("index.ts");

    let content = r#"// Auto-generated by FORGE - DO NOT EDIT

// Types
export * from './types';

// API bindings
export * from './api';

// Stores
export * from './stores';

// Client (re-exported from @forge/svelte)
export { ForgeClient, ForgeClientError, createForgeClient, ForgeProvider } from '@forge/svelte';
"#;

    fs::write(file_path, content)?;

    // Also generate client.ts
    generate_client(output_dir)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_generate_types() {
        let dir = tempdir().unwrap();
        generate_types(dir.path(), false).unwrap();
        assert!(dir.path().join("types.ts").exists());
    }

    #[test]
    fn test_generate_api() {
        let dir = tempdir().unwrap();
        generate_api(dir.path(), false).unwrap();
        assert!(dir.path().join("api.ts").exists());
    }

    #[test]
    fn test_generate_stores() {
        let dir = tempdir().unwrap();
        generate_stores(dir.path(), false).unwrap();
        assert!(dir.path().join("stores.ts").exists());
    }
}
