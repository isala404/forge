//! Runtime Generator
//!
//! Generates the `.forge/svelte/` package directory containing the @forge/svelte runtime.
//! This runtime is regenerated by `forge generate` to keep it in sync with the CLI version.

use anyhow::Result;
use std::fs;
use std::path::Path;

/// Current FORGE CLI version (used for version tracking)
pub const FORGE_VERSION: &str = env!("CARGO_PKG_VERSION");

/// Check if the project has a legacy runtime structure (embedded in src/lib/forge/runtime/)
pub fn has_legacy_runtime(frontend_dir: &Path) -> bool {
    frontend_dir.join("src/lib/forge/runtime/index.ts").exists()
}

/// Get the version of the runtime currently installed in the project
pub fn get_installed_version(frontend_dir: &Path) -> Option<String> {
    let version_file = frontend_dir.join(".forge/version");
    fs::read_to_string(version_file)
        .ok()
        .map(|s| s.trim().to_string())
}

/// Check if a runtime update is needed
pub fn needs_update(frontend_dir: &Path) -> bool {
    match get_installed_version(frontend_dir) {
        Some(installed) => installed != FORGE_VERSION,
        None => true, // No version file means we need to generate
    }
}

/// Generate the .forge/svelte/ package in the frontend directory.
///
/// This creates:
/// - `.forge/svelte/package.json` - NPM package manifest
/// - `.forge/svelte/index.ts` - Main exports
/// - `.forge/svelte/types.ts` - Type definitions
/// - `.forge/svelte/client.ts` - ForgeClient class
/// - `.forge/svelte/context.ts` - Svelte context utilities
/// - `.forge/svelte/stores.ts` - Svelte store functions
/// - `.forge/svelte/api.ts` - API helper functions
/// - `.forge/svelte/ForgeProvider.svelte` - Root provider component
/// - `.forge/version` - Version tracking file
pub fn generate_runtime(frontend_dir: &Path) -> Result<()> {
    let forge_dir = frontend_dir.join(".forge");
    let svelte_dir = forge_dir.join("svelte");

    // Create directories
    fs::create_dir_all(&svelte_dir)?;

    // Write version file
    fs::write(forge_dir.join("version"), FORGE_VERSION)?;

    // Generate package.json
    generate_package_json(&svelte_dir)?;

    // Generate all runtime files
    generate_types(&svelte_dir)?;
    generate_client(&svelte_dir)?;
    generate_context(&svelte_dir)?;
    generate_stores(&svelte_dir)?;
    generate_api(&svelte_dir)?;
    generate_provider(&svelte_dir)?;
    generate_index(&svelte_dir)?;

    Ok(())
}

/// Update the frontend package.json to include the @forge/svelte dependency
pub fn update_frontend_package_json(frontend_dir: &Path) -> Result<()> {
    let package_json_path = frontend_dir.join("package.json");

    if !package_json_path.exists() {
        return Ok(()); // No package.json to update
    }

    let content = fs::read_to_string(&package_json_path)?;

    // Check if already has the dependency
    if content.contains("\"@forge/svelte\"") {
        return Ok(());
    }

    // Parse and update the JSON
    let mut json: serde_json::Value = serde_json::from_str(&content)?;

    if let Some(deps) = json.get_mut("dependencies") {
        if let Some(obj) = deps.as_object_mut() {
            obj.insert(
                "@forge/svelte".to_string(),
                serde_json::Value::String("file:./.forge/svelte".to_string()),
            );
        }
    } else {
        // Create dependencies object if it doesn't exist
        let mut deps = serde_json::Map::new();
        deps.insert(
            "@forge/svelte".to_string(),
            serde_json::Value::String("file:./.forge/svelte".to_string()),
        );
        json["dependencies"] = serde_json::Value::Object(deps);
    }

    // Write back with pretty formatting
    let formatted = serde_json::to_string_pretty(&json)?;
    fs::write(&package_json_path, formatted)?;

    Ok(())
}

/// Remove legacy runtime directory (src/lib/forge/runtime/)
pub fn remove_legacy_runtime(frontend_dir: &Path) -> Result<()> {
    let legacy_dir = frontend_dir.join("src/lib/forge/runtime");
    if legacy_dir.exists() {
        fs::remove_dir_all(legacy_dir)?;
    }
    Ok(())
}

/// Generate package.json for the @forge/svelte package
fn generate_package_json(svelte_dir: &Path) -> Result<()> {
    let content = format!(
        r#"{{
  "name": "@forge/svelte",
  "version": "{version}",
  "type": "module",
  "main": "./index.ts",
  "types": "./index.ts",
  "exports": {{
    ".": "./index.ts",
    "./client": "./client.ts",
    "./stores": "./stores.ts",
    "./context": "./context.ts"
  }},
  "peerDependencies": {{
    "svelte": "^5.0.0"
  }}
}}"#,
        version = FORGE_VERSION
    );
    fs::write(svelte_dir.join("package.json"), content)?;
    Ok(())
}

/// Generate types.ts
fn generate_types(svelte_dir: &Path) -> Result<()> {
    let content = format!(
        r#"// Auto-generated by FORGE v{version} - DO NOT EDIT
// Regenerate with: forge generate

// FORGE error type returned from the server
export interface ForgeError {{
  code: string;
  message: string;
  details?: Record<string, unknown>;
}}

// Result of a query operation
export interface QueryResult<T> {{
  loading: boolean;
  data: T | null;
  error: ForgeError | null;
}}

// Result of a subscription operation
export interface SubscriptionResult<T> extends QueryResult<T> {{
  stale: boolean;
}}

// WebSocket connection state
export type ConnectionState = 'connecting' | 'connected' | 'reconnecting' | 'disconnected';

// Auth state for the current user
export interface AuthState {{
  user: unknown | null;
  token: string | null;
  loading: boolean;
}}

// Function type definitions for type-safe RPC calls
export interface QueryFn<TArgs, TResult> {{
  (client: ForgeClientInterface, args: TArgs): Promise<TResult>;
  functionName: string;
  functionType: 'query';
}}

export interface MutationFn<TArgs, TResult> {{
  (client: ForgeClientInterface, args: TArgs): Promise<TResult>;
  functionName: string;
  functionType: 'mutation';
}}

export interface ActionFn<TArgs, TResult> {{
  (client: ForgeClientInterface, args: TArgs): Promise<TResult>;
  functionName: string;
  functionType: 'action';
}}

// FORGE client interface for making RPC calls
export interface ForgeClientInterface {{
  call<T>(functionName: string, args: unknown): Promise<T>;
  subscribe<T>(functionName: string, args: unknown, callback: (data: T) => void): () => void;
  getConnectionState(): ConnectionState;
  connect(): Promise<void>;
  disconnect(): void;
}}

// Job status enum
export type JobStatus = 'pending' | 'claimed' | 'running' | 'completed' | 'retry' | 'failed' | 'dead_letter';

// Job progress information
export interface JobProgress {{
  job_id: string;
  status: JobStatus;
  progress_percent: number | null;
  progress_message: string | null;
  output: unknown | null;
  error: string | null;
}}

// Workflow status enum
export type WorkflowStatus = 'created' | 'running' | 'waiting' | 'completed' | 'compensating' | 'compensated' | 'failed';

// Workflow step status enum
export type WorkflowStepStatus = 'pending' | 'running' | 'completed' | 'failed' | 'compensated' | 'skipped';

// Workflow step information
export interface WorkflowStep {{
  name: string;
  status: WorkflowStepStatus;
  started_at: string | null;
  completed_at: string | null;
  error: string | null;
}}

// Workflow progress information
export interface WorkflowProgress {{
  workflow_id: string;
  status: WorkflowStatus;
  current_step: string | null;
  steps: WorkflowStep[];
  output: unknown | null;
  error: string | null;
}}
"#,
        version = FORGE_VERSION
    );
    fs::write(svelte_dir.join("types.ts"), content)?;
    Ok(())
}

/// Generate client.ts
fn generate_client(svelte_dir: &Path) -> Result<()> {
    let content = format!(
        r#"// Auto-generated by FORGE v{version} - DO NOT EDIT
// Regenerate with: forge generate

import type {{ ForgeError, ConnectionState, ForgeClientInterface, JobProgress, WorkflowProgress }} from './types.js';

export interface ForgeClientConfig {{
  url: string;
  getToken?: () => string | null | Promise<string | null>;
  onAuthError?: (error: ForgeError) => void;
  timeout?: number;
}}

interface RpcResponse<T = unknown> {{
  success: boolean;
  data?: T;
  error?: ForgeError;
}}

interface WsMessage {{
  type: string;
  id?: string;
  data?: unknown;
  error?: ForgeError;
}}

export class ForgeClientError extends Error {{
  code: string;
  constructor(code: string, message: string) {{
    super(message);
    this.name = 'ForgeClientError';
    this.code = code;
  }}
}}

export class ForgeClient implements ForgeClientInterface {{
  private config: ForgeClientConfig;
  private ws: WebSocket | null = null;
  private connectionState: ConnectionState = 'disconnected';
  private subscriptions = new Map<string, (data: unknown) => void>();
  private pendingSubscriptions = new Map<string, {{ functionName: string; args: unknown }}>();
  private connectionListeners = new Set<(state: ConnectionState) => void>();
  // Job/Workflow subscription tracking
  private jobCallbacks = new Map<string, (data: JobProgress) => void>();
  private workflowCallbacks = new Map<string, (data: WorkflowProgress) => void>();
  private pendingJobSubscriptions = new Map<string, string>(); // subId -> jobId
  private pendingWorkflowSubscriptions = new Map<string, string>(); // subId -> workflowId

  constructor(config: ForgeClientConfig) {{
    this.config = config;
  }}

  getConnectionState(): ConnectionState {{
    return this.connectionState;
  }}

  onConnectionStateChange(listener: (state: ConnectionState) => void): () => void {{
    this.connectionListeners.add(listener);
    return () => this.connectionListeners.delete(listener);
  }}

  async connect(): Promise<void> {{
    if (this.ws?.readyState === WebSocket.OPEN) return;

    return new Promise((resolve) => {{
      const wsUrl = this.config.url.replace(/^http/, 'ws') + '/ws';
      this.setConnectionState('connecting');

      try {{
        this.ws = new WebSocket(wsUrl);
      }} catch {{
        this.setConnectionState('disconnected');
        resolve();
        return;
      }}

      this.ws.onopen = async () => {{
        const token = await this.getToken();
        if (token) this.ws?.send(JSON.stringify({{ type: 'auth', token }}));
        this.setConnectionState('connected');
        this.flushPendingSubscriptions();
        resolve();
      }};

      this.ws.onerror = () => {{
        this.setConnectionState('disconnected');
        resolve();
      }};

      this.ws.onclose = () => this.setConnectionState('disconnected');
      this.ws.onmessage = (event) => this.handleMessage(event.data);
    }});
  }}

  disconnect(): void {{
    this.ws?.close();
    this.ws = null;
    this.setConnectionState('disconnected');
    this.subscriptions.clear();
  }}

  async call<T>(functionName: string, args: unknown): Promise<T> {{
    const token = await this.getToken();
    const normalizedArgs = args && typeof args === 'object' && Object.keys(args).length === 0 ? null : args;

    const response = await fetch(`${{this.config.url}}/rpc/${{functionName}}`, {{
      method: 'POST',
      headers: {{
        'Content-Type': 'application/json',
        ...(token ? {{ 'Authorization': `Bearer ${{token}}` }} : {{}}),
      }},
      body: JSON.stringify(normalizedArgs),
    }});

    const result: RpcResponse<T> = await response.json();
    if (!result.success || result.error) {{
      const error = result.error || {{ code: 'UNKNOWN', message: 'Unknown error' }};
      throw new ForgeClientError(error.code, error.message);
    }}
    return result.data as T;
  }}

  subscribe<T>(functionName: string, args: unknown, callback: (data: T) => void): () => void {{
    const subscriptionId = Math.random().toString(36).substring(2, 15);
    this.subscriptions.set(subscriptionId, callback as (data: unknown) => void);

    const normalizedArgs = args && typeof args === 'object' && Object.keys(args).length === 0 ? null : args;

    if (this.ws?.readyState === WebSocket.OPEN) {{
      this.ws.send(JSON.stringify({{ type: 'subscribe', id: subscriptionId, function: functionName, args: normalizedArgs }}));
    }} else {{
      this.pendingSubscriptions.set(subscriptionId, {{ functionName, args: normalizedArgs }});
    }}

    return () => {{
      this.subscriptions.delete(subscriptionId);
      this.pendingSubscriptions.delete(subscriptionId);
      if (this.ws?.readyState === WebSocket.OPEN) {{
        this.ws.send(JSON.stringify({{ type: 'unsubscribe', id: subscriptionId }}));
      }}
    }};
  }}

  /** Subscribe to job progress updates. */
  subscribeJob(jobId: string, callback: (data: JobProgress) => void): () => void {{
    const subId = `job_${{jobId}}_${{Date.now()}}`;
    this.jobCallbacks.set(subId, callback);
    this.pendingJobSubscriptions.set(subId, jobId);

    if (this.ws?.readyState === WebSocket.OPEN) {{
      this.ws.send(JSON.stringify({{ type: 'subscribe_job', id: subId, job_id: jobId }}));
    }}

    return () => {{
      this.jobCallbacks.delete(subId);
      this.pendingJobSubscriptions.delete(subId);
      if (this.ws?.readyState === WebSocket.OPEN) {{
        this.ws.send(JSON.stringify({{ type: 'unsubscribe_job', id: subId }}));
      }}
    }};
  }}

  /** Subscribe to workflow progress updates. */
  subscribeWorkflow(workflowId: string, callback: (data: WorkflowProgress) => void): () => void {{
    const subId = `workflow_${{workflowId}}_${{Date.now()}}`;
    this.workflowCallbacks.set(subId, callback);
    this.pendingWorkflowSubscriptions.set(subId, workflowId);

    if (this.ws?.readyState === WebSocket.OPEN) {{
      this.ws.send(JSON.stringify({{ type: 'subscribe_workflow', id: subId, workflow_id: workflowId }}));
    }}

    return () => {{
      this.workflowCallbacks.delete(subId);
      this.pendingWorkflowSubscriptions.delete(subId);
      if (this.ws?.readyState === WebSocket.OPEN) {{
        this.ws.send(JSON.stringify({{ type: 'unsubscribe_workflow', id: subId }}));
      }}
    }};
  }}

  private flushPendingSubscriptions(): void {{
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
    for (const [id, {{ functionName, args }}] of this.pendingSubscriptions) {{
      this.ws.send(JSON.stringify({{ type: 'subscribe', id, function: functionName, args }}));
    }}
    this.pendingSubscriptions.clear();
    // Re-subscribe job subscriptions
    for (const [subId, jobId] of this.pendingJobSubscriptions) {{
      this.ws.send(JSON.stringify({{ type: 'subscribe_job', id: subId, job_id: jobId }}));
    }}
    // Re-subscribe workflow subscriptions
    for (const [subId, workflowId] of this.pendingWorkflowSubscriptions) {{
      this.ws.send(JSON.stringify({{ type: 'subscribe_workflow', id: subId, workflow_id: workflowId }}));
    }}
  }}

  private async getToken(): Promise<string | null> {{
    return this.config.getToken?.() ?? null;
  }}

  private setConnectionState(state: ConnectionState): void {{
    this.connectionState = state;
    this.connectionListeners.forEach(listener => listener(state));
  }}

  private handleMessage(data: string): void {{
    try {{
      const message = JSON.parse(data) as WsMessage & {{ job?: JobProgress; workflow?: WorkflowProgress }};
      if ((message.type === 'data' || message.type === 'delta') && message.id) {{
        const callback = this.subscriptions.get(message.id);
        if (callback) callback(message.data);
      }} else if (message.type === 'job_update' && message.id && message.job) {{
        const callback = this.jobCallbacks.get(message.id);
        if (callback) callback(message.job);
      }} else if (message.type === 'workflow_update' && message.id && message.workflow) {{
        const callback = this.workflowCallbacks.get(message.id);
        if (callback) callback(message.workflow);
      }}
    }} catch {{}}
  }}
}}

export function createForgeClient(config: ForgeClientConfig): ForgeClient {{
  return new ForgeClient(config);
}}
"#,
        version = FORGE_VERSION
    );
    fs::write(svelte_dir.join("client.ts"), content)?;
    Ok(())
}

/// Generate context.ts
fn generate_context(svelte_dir: &Path) -> Result<()> {
    let content = format!(
        r#"// Auto-generated by FORGE v{version} - DO NOT EDIT
// Regenerate with: forge generate

import {{ getContext, setContext }} from 'svelte';
import type {{ ForgeClient }} from './client.js';
import type {{ AuthState }} from './types.js';

const FORGE_CLIENT_KEY = Symbol('forge-client');
const FORGE_AUTH_KEY = Symbol('forge-auth');
let globalClient: ForgeClient | null = null;

export function getForgeClient(): ForgeClient {{
  try {{
    const client = getContext<ForgeClient>(FORGE_CLIENT_KEY);
    if (client) return client;
  }} catch {{}}
  if (globalClient) return globalClient;
  throw new Error('FORGE client not found. Wrap your component with ForgeProvider.');
}}

export function setForgeClient(client: ForgeClient): void {{
  setContext(FORGE_CLIENT_KEY, client);
  globalClient = client;
}}

export function getAuthState(): AuthState {{
  const auth = getContext<AuthState>(FORGE_AUTH_KEY);
  if (!auth) throw new Error('Auth state not found.');
  return auth;
}}

export function setAuthState(auth: AuthState): void {{
  setContext(FORGE_AUTH_KEY, auth);
}}
"#,
        version = FORGE_VERSION
    );
    fs::write(svelte_dir.join("context.ts"), content)?;
    Ok(())
}

/// Generate stores.ts
fn generate_stores(svelte_dir: &Path) -> Result<()> {
    let content = format!(
        r#"// Auto-generated by FORGE v{version} - DO NOT EDIT
// Regenerate with: forge generate

import {{ getForgeClient }} from './context.js';
import type {{ QueryResult, SubscriptionResult, ForgeError, QueryFn, MutationFn, ActionFn, JobProgress, WorkflowProgress, JobStatus, WorkflowStatus }} from './types.js';

export interface Readable<T> {{
  subscribe: (run: (value: T) => void) => () => void;
}}

export interface SubscriptionStore<T> extends Readable<SubscriptionResult<T>> {{
  refetch: () => Promise<void>;
  unsubscribe: () => void;
}}

export async function query<TArgs, TResult>(fn: QueryFn<TArgs, TResult>, args: TArgs): Promise<QueryResult<TResult>> {{
  const client = getForgeClient();
  try {{
    const data = await fn(client, args);
    return {{ loading: false, data, error: null }};
  }} catch (e) {{
    return {{ loading: false, data: null, error: e as ForgeError }};
  }}
}}

export function subscribe<TArgs, TResult>(fn: QueryFn<TArgs, TResult>, args: TArgs): SubscriptionStore<TResult> {{
  const client = getForgeClient();
  const subscribers = new Set<(value: SubscriptionResult<TResult>) => void>();
  let unsubscribeFn: (() => void) | null = null;
  let state: SubscriptionResult<TResult> = {{ loading: true, data: null, error: null, stale: false }};

  const notify = () => subscribers.forEach(run => run(state));

  const startSubscription = async () => {{
    if (unsubscribeFn) {{ unsubscribeFn(); unsubscribeFn = null; }}
    state = {{ ...state, loading: true, error: null, stale: false }};
    notify();

    try {{
      const initialData = await fn(client, args);
      state = {{ loading: false, data: initialData, error: null, stale: false }};
      notify();

      unsubscribeFn = client.subscribe(fn.functionName, args, (data: TResult) => {{
        state = {{ loading: false, data, error: null, stale: false }};
        notify();
      }});
    }} catch (e) {{
      state = {{ loading: false, data: null, error: e as ForgeError, stale: false }};
      notify();
    }}
  }};

  startSubscription();

  return {{
    subscribe(run) {{
      subscribers.add(run);
      run(state);
      return () => {{
        subscribers.delete(run);
        if (subscribers.size === 0 && unsubscribeFn) {{ unsubscribeFn(); unsubscribeFn = null; }}
      }};
    }},
    refetch: startSubscription,
    unsubscribe: () => {{ if (unsubscribeFn) {{ unsubscribeFn(); unsubscribeFn = null; }} }},
  }};
}}

export async function mutate<TArgs, TResult>(fn: MutationFn<TArgs, TResult>, args: TArgs): Promise<TResult> {{
  const client = getForgeClient();
  return fn(client, args);
}}

export async function action<TArgs, TResult>(fn: ActionFn<TArgs, TResult>, args: TArgs): Promise<TResult> {{
  const client = getForgeClient();
  return fn(client, args);
}}

export interface JobStore extends Readable<JobProgress & {{ loading: boolean }}> {{
  unsubscribe: () => void;
}}

export interface WorkflowStore extends Readable<WorkflowProgress & {{ loading: boolean }}> {{
  unsubscribe: () => void;
}}

const uuidRegex = /^[0-9a-f]{{8}}-[0-9a-f]{{4}}-[0-9a-f]{{4}}-[0-9a-f]{{4}}-[0-9a-f]{{12}}$/i;

export function subscribeJob(jobId: string): JobStore {{
  if (!uuidRegex.test(jobId)) {{
    throw new Error('Invalid job ID: must be a valid UUID');
  }}

  const client = getForgeClient();
  const subscribers = new Set<(value: JobProgress & {{ loading: boolean }}) => void>();
  let state: JobProgress & {{ loading: boolean }} = {{
    job_id: jobId,
    status: 'pending' as JobStatus,
    progress_percent: null,
    progress_message: null,
    output: null,
    error: null,
    loading: true,
  }};

  const notify = () => subscribers.forEach(run => run(state));

  const unsubscribeFn = client.subscribeJob(jobId, (data: JobProgress) => {{
    state = {{ ...data, loading: false }};
    notify();
  }});

  return {{
    subscribe(run) {{
      subscribers.add(run);
      run(state);
      return () => {{
        subscribers.delete(run);
        if (subscribers.size === 0) unsubscribeFn();
      }};
    }},
    unsubscribe: unsubscribeFn,
  }};
}}

export function subscribeWorkflow(workflowId: string): WorkflowStore {{
  if (!uuidRegex.test(workflowId)) {{
    throw new Error('Invalid workflow ID: must be a valid UUID');
  }}

  const client = getForgeClient();
  const subscribers = new Set<(value: WorkflowProgress & {{ loading: boolean }}) => void>();
  let state: WorkflowProgress & {{ loading: boolean }} = {{
    workflow_id: workflowId,
    status: 'created' as WorkflowStatus,
    current_step: null,
    steps: [],
    output: null,
    error: null,
    loading: true,
  }};

  const notify = () => subscribers.forEach(run => run(state));

  const unsubscribeFn = client.subscribeWorkflow(workflowId, (data: WorkflowProgress) => {{
    state = {{ ...data, loading: false }};
    notify();
  }});

  return {{
    subscribe(run) {{
      subscribers.add(run);
      run(state);
      return () => {{
        subscribers.delete(run);
        if (subscribers.size === 0) unsubscribeFn();
      }};
    }},
    unsubscribe: unsubscribeFn,
  }};
}}

export interface JobTracker<TArgs> extends Readable<JobProgress | null> {{
  start: (args: TArgs) => Promise<string>;
  resume: (jobId: string) => void;
  cleanup: () => void;
}}

export interface WorkflowTracker<TArgs> extends Readable<WorkflowProgress | null> {{
  start: (args: TArgs) => Promise<string>;
  resume: (workflowId: string) => void;
  cleanup: () => void;
}}

export function createJobTracker<TArgs>(jobType: string, apiUrl: string): JobTracker<TArgs> {{
  const client = getForgeClient();
  const subscribers = new Set<(value: JobProgress | null) => void>();
  let state: JobProgress | null = null;
  let unsubscribeFn: (() => void) | null = null;

  const notify = () => subscribers.forEach(run => run(state));

  const subscribeToJob = (jobId: string) => {{
    if (!uuidRegex.test(jobId)) {{
      throw new Error('Invalid job ID: must be a valid UUID');
    }}

    if (unsubscribeFn) {{
      unsubscribeFn();
      unsubscribeFn = null;
    }}

    state = {{
      job_id: jobId,
      status: 'pending' as JobStatus,
      progress_percent: null,
      progress_message: null,
      output: null,
      error: null,
    }};
    notify();

    unsubscribeFn = client.subscribeJob(jobId, (data: JobProgress) => {{
      state = data;
      notify();
    }});
  }};

  return {{
    subscribe(run) {{
      subscribers.add(run);
      run(state);
      return () => {{
        subscribers.delete(run);
      }};
    }},

    async start(args: TArgs): Promise<string> {{
      const response = await fetch(`${{apiUrl}}/_api/jobs/${{jobType}}/dispatch`, {{
        method: 'POST',
        headers: {{ 'Content-Type': 'application/json' }},
        body: JSON.stringify({{ args: args || {{}} }}),
      }});

      const result = await response.json();
      if (result.error || !result.data?.job_id) {{
        throw new Error(result.error?.message || 'Failed to dispatch job');
      }}

      const jobId = result.data.job_id;
      subscribeToJob(jobId);
      return jobId;
    }},

    resume(jobId: string) {{
      subscribeToJob(jobId);
    }},

    cleanup() {{
      if (unsubscribeFn) {{
        unsubscribeFn();
        unsubscribeFn = null;
      }}
      state = null;
      notify();
    }},
  }};
}}

export function createWorkflowTracker<TArgs>(workflowType: string, apiUrl: string): WorkflowTracker<TArgs> {{
  const client = getForgeClient();
  const subscribers = new Set<(value: WorkflowProgress | null) => void>();
  let state: WorkflowProgress | null = null;
  let unsubscribeFn: (() => void) | null = null;

  const notify = () => subscribers.forEach(run => run(state));

  const subscribeToWorkflow = (workflowId: string) => {{
    if (!uuidRegex.test(workflowId)) {{
      throw new Error('Invalid workflow ID: must be a valid UUID');
    }}

    if (unsubscribeFn) {{
      unsubscribeFn();
      unsubscribeFn = null;
    }}

    state = {{
      workflow_id: workflowId,
      status: 'created' as WorkflowStatus,
      current_step: null,
      steps: [],
      output: null,
      error: null,
    }};
    notify();

    unsubscribeFn = client.subscribeWorkflow(workflowId, (data: WorkflowProgress) => {{
      state = data;
      notify();
    }});
  }};

  return {{
    subscribe(run) {{
      subscribers.add(run);
      run(state);
      return () => {{
        subscribers.delete(run);
      }};
    }},

    async start(args: TArgs): Promise<string> {{
      const response = await fetch(`${{apiUrl}}/_api/workflows/${{workflowType}}/start`, {{
        method: 'POST',
        headers: {{ 'Content-Type': 'application/json' }},
        body: JSON.stringify({{ input: args || {{}} }}),
      }});

      const result = await response.json();
      if (result.error || !result.data?.workflow_id) {{
        throw new Error(result.error?.message || 'Failed to start workflow');
      }}

      const workflowId = result.data.workflow_id;
      subscribeToWorkflow(workflowId);
      return workflowId;
    }},

    resume(workflowId: string) {{
      subscribeToWorkflow(workflowId);
    }},

    cleanup() {{
      if (unsubscribeFn) {{
        unsubscribeFn();
        unsubscribeFn = null;
      }}
      state = null;
      notify();
    }},
  }};
}}
"#,
        version = FORGE_VERSION
    );
    fs::write(svelte_dir.join("stores.ts"), content)?;
    Ok(())
}

/// Generate api.ts
fn generate_api(svelte_dir: &Path) -> Result<()> {
    let content = format!(
        r#"// Auto-generated by FORGE v{version} - DO NOT EDIT
// Regenerate with: forge generate

import type {{ ForgeClientInterface, QueryFn, MutationFn, ActionFn }} from './types.js';

export function createQuery<TArgs, TResult>(name: string): QueryFn<TArgs, TResult> {{
  const fn = async (client: ForgeClientInterface, args: TArgs): Promise<TResult> => {{
    return client.call(name, args);
  }};
  (fn as QueryFn<TArgs, TResult>).functionName = name;
  (fn as QueryFn<TArgs, TResult>).functionType = 'query';
  return fn as QueryFn<TArgs, TResult>;
}}

export function createMutation<TArgs, TResult>(name: string): MutationFn<TArgs, TResult> {{
  const fn = async (client: ForgeClientInterface, args: TArgs): Promise<TResult> => {{
    return client.call(name, args);
  }};
  (fn as MutationFn<TArgs, TResult>).functionName = name;
  (fn as MutationFn<TArgs, TResult>).functionType = 'mutation';
  return fn as MutationFn<TArgs, TResult>;
}}

export function createAction<TArgs, TResult>(name: string): ActionFn<TArgs, TResult> {{
  const fn = async (client: ForgeClientInterface, args: TArgs): Promise<TResult> => {{
    return client.call(name, args);
  }};
  (fn as ActionFn<TArgs, TResult>).functionName = name;
  (fn as ActionFn<TArgs, TResult>).functionType = 'action';
  return fn as ActionFn<TArgs, TResult>;
}}
"#,
        version = FORGE_VERSION
    );
    fs::write(svelte_dir.join("api.ts"), content)?;
    Ok(())
}

/// Generate ForgeProvider.svelte
fn generate_provider(svelte_dir: &Path) -> Result<()> {
    let content = format!(
        r#"<!--
  Auto-generated by FORGE v{version} - DO NOT EDIT
  Regenerate with: forge generate
-->
<script lang="ts">
  import {{ onMount, onDestroy, type Snippet }} from 'svelte';
  import {{ createForgeClient }} from './client.js';
  import {{ setForgeClient, setAuthState }} from './context.js';
  import type {{ AuthState, ConnectionState }} from './types.js';

  interface Props {{
    url: string;
    getToken?: () => string | null | Promise<string | null>;
    onConnectionChange?: (state: ConnectionState) => void;
    children: Snippet;
  }}

  let props: Props = $props();

  const client = createForgeClient({{
    url: props.url,
    getToken: props.getToken,
  }});

  setForgeClient(client);

  const authState: AuthState = $state({{ user: null, token: null, loading: true }});
  setAuthState(authState);

  onMount(() => {{
    const unsubscribe = client.onConnectionStateChange((state) => {{
      props.onConnectionChange?.(state);
    }});

    (async () => {{
      try {{ await client.connect(); }} catch {{}}
      if (props.getToken) {{
        authState.token = await props.getToken();
      }}
      authState.loading = false;
    }})();

    return unsubscribe;
  }});

  onDestroy(() => client.disconnect());
</script>

{{@render props.children()}}
"#,
        version = FORGE_VERSION
    );
    fs::write(svelte_dir.join("ForgeProvider.svelte"), content)?;
    Ok(())
}

/// Generate index.ts
fn generate_index(svelte_dir: &Path) -> Result<()> {
    let content = format!(
        r#"// Auto-generated by FORGE v{version} - DO NOT EDIT
// Regenerate with: forge generate

export {{ default as ForgeProvider }} from './ForgeProvider.svelte';
export {{ ForgeClient, ForgeClientError, createForgeClient, type ForgeClientConfig }} from './client.js';
export {{ getForgeClient, setForgeClient, getAuthState, setAuthState }} from './context.js';
export {{
  query, subscribe, mutate, action,
  subscribeJob, subscribeWorkflow,
  createJobTracker, createWorkflowTracker,
  type Readable, type SubscriptionStore, type JobStore, type WorkflowStore,
  type JobTracker, type WorkflowTracker,
}} from './stores.js';
export {{ createQuery, createMutation, createAction }} from './api.js';
export type {{
  ForgeError, QueryResult, SubscriptionResult, ConnectionState, AuthState,
  QueryFn, MutationFn, ActionFn, ForgeClientInterface,
  JobProgress, WorkflowProgress, JobStatus, WorkflowStatus, WorkflowStep, WorkflowStepStatus,
}} from './types.js';
"#,
        version = FORGE_VERSION
    );
    fs::write(svelte_dir.join("index.ts"), content)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_generate_runtime() {
        let dir = tempdir().unwrap();
        generate_runtime(dir.path()).unwrap();

        assert!(dir.path().join(".forge/version").exists());
        assert!(dir.path().join(".forge/svelte/package.json").exists());
        assert!(dir.path().join(".forge/svelte/index.ts").exists());
        assert!(dir.path().join(".forge/svelte/types.ts").exists());
        assert!(dir.path().join(".forge/svelte/client.ts").exists());
        assert!(dir.path().join(".forge/svelte/context.ts").exists());
        assert!(dir.path().join(".forge/svelte/stores.ts").exists());
        assert!(dir.path().join(".forge/svelte/api.ts").exists());
        assert!(dir
            .path()
            .join(".forge/svelte/ForgeProvider.svelte")
            .exists());
    }

    #[test]
    fn test_version_file() {
        let dir = tempdir().unwrap();
        generate_runtime(dir.path()).unwrap();

        let version = fs::read_to_string(dir.path().join(".forge/version")).unwrap();
        assert_eq!(version.trim(), FORGE_VERSION);
    }

    #[test]
    fn test_needs_update() {
        let dir = tempdir().unwrap();

        // No version file = needs update
        assert!(needs_update(dir.path()));

        // Generate runtime
        generate_runtime(dir.path()).unwrap();

        // Same version = no update needed
        assert!(!needs_update(dir.path()));

        // Different version = needs update
        fs::write(dir.path().join(".forge/version"), "0.0.0").unwrap();
        assert!(needs_update(dir.path()));
    }

    #[test]
    fn test_has_legacy_runtime() {
        let dir = tempdir().unwrap();

        // No legacy runtime
        assert!(!has_legacy_runtime(dir.path()));

        // Create legacy structure
        let legacy_dir = dir.path().join("src/lib/forge/runtime");
        fs::create_dir_all(&legacy_dir).unwrap();
        fs::write(legacy_dir.join("index.ts"), "// legacy").unwrap();

        assert!(has_legacy_runtime(dir.path()));
    }
}
