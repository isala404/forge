// Auto-generated by FORGE v{{version}} - DO NOT EDIT
// Regenerate with: forge generate

import { getForgeClient } from "./context.js";
import type {
  QueryResult,
  SubscriptionResult,
  ForgeError,
  QueryFn,
  MutationFn,
  ActionFn,
  JobProgress,
  WorkflowProgress,
  JobStatus,
  WorkflowStatus,
  ConnectionState,
} from "./types.js";

export interface Readable<T> {
  subscribe: (run: (value: T) => void) => () => void;
}

export interface ConnectionStatusStore extends Readable<ConnectionState> {
  get(): ConnectionState;
}

export interface SubscriptionStore<T> extends Readable<SubscriptionResult<T>> {
  refetch: () => Promise<void>;
  unsubscribe: () => void;
  reset: () => void;
}

/**
 * Create a reactive store for WebSocket connection status.
 * Use this to show connection state in your UI.
 */
export function createConnectionStore(): ConnectionStatusStore {
  const client = getForgeClient();
  const subscribers = new Set<(value: ConnectionState) => void>();
  let currentState: ConnectionState = client.getConnectionState();

  // Subscribe to client connection state changes
  client.onConnectionStateChange((state) => {
    currentState = state;
    subscribers.forEach((run) => run(state));
  });

  return {
    subscribe(run) {
      subscribers.add(run);
      run(currentState);
      return () => subscribers.delete(run);
    },
    get() {
      return currentState;
    },
  };
}

export async function query<TArgs, TResult>(
  fn: QueryFn<TArgs, TResult>,
  args: TArgs,
): Promise<QueryResult<TResult>> {
  const client = getForgeClient();
  try {
    const data = await fn(client, args);
    return { loading: false, data, error: null };
  } catch (e) {
    return { loading: false, data: null, error: e as ForgeError };
  }
}

export function subscribe<TArgs, TResult>(
  fn: QueryFn<TArgs, TResult>,
  args: TArgs,
): SubscriptionStore<TResult> {
  const client = getForgeClient();
  const subscribers = new Set<(value: SubscriptionResult<TResult>) => void>();
  let unsubscribeFn: (() => void) | null = null;
  let state: SubscriptionResult<TResult> = {
    loading: true,
    data: null,
    error: null,
    stale: false,
  };

  const notify = () => subscribers.forEach((run) => run(state));

  const startSubscription = async () => {
    if (unsubscribeFn) {
      unsubscribeFn();
      unsubscribeFn = null;
    }
    state = { ...state, loading: true, error: null, stale: false };
    notify();

    try {
      const initialData = await fn(client, args);
      state = { loading: false, data: initialData, error: null, stale: false };
      notify();

      unsubscribeFn = client.subscribe(
        fn.functionName,
        args,
        (data: TResult) => {
          state = { loading: false, data, error: null, stale: false };
          notify();
        },
      );
    } catch (e) {
      state = {
        loading: false,
        data: null,
        error: e as ForgeError,
        stale: false,
      };
      notify();
    }
  };

  startSubscription();

  return {
    subscribe(run) {
      subscribers.add(run);
      run(state);
      return () => {
        subscribers.delete(run);
        if (subscribers.size === 0 && unsubscribeFn) {
          unsubscribeFn();
          unsubscribeFn = null;
        }
      };
    },
    refetch: startSubscription,
    unsubscribe: () => {
      if (unsubscribeFn) {
        unsubscribeFn();
        unsubscribeFn = null;
      }
    },
    reset: () => {
      state = { loading: true, data: null, error: null, stale: false };
      notify();
    },
  };
}

export async function mutate<TArgs, TResult>(
  fn: MutationFn<TArgs, TResult>,
  args: TArgs,
): Promise<TResult> {
  const client = getForgeClient();
  return fn(client, args);
}

export async function action<TArgs, TResult>(
  fn: ActionFn<TArgs, TResult>,
  args: TArgs,
): Promise<TResult> {
  const client = getForgeClient();
  return fn(client, args);
}

export interface JobStore extends Readable<JobProgress & { loading: boolean }> {
  unsubscribe: () => void;
}

export interface WorkflowStore
  extends Readable<WorkflowProgress & { loading: boolean }> {
  unsubscribe: () => void;
}

const uuidRegex =
  /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

export function subscribeJob(jobId: string): JobStore {
  if (!uuidRegex.test(jobId)) {
    throw new Error("Invalid job ID: must be a valid UUID");
  }

  const client = getForgeClient();
  const subscribers = new Set<
    (value: JobProgress & { loading: boolean }) => void
  >();
  let state: JobProgress & { loading: boolean } = {
    job_id: jobId,
    status: "pending" as JobStatus,
    progress_percent: null,
    progress_message: null,
    output: null,
    error: null,
    loading: true,
  };

  const notify = () => subscribers.forEach((run) => run(state));

  const unsubscribeFn = client.subscribeJob(jobId, (data: JobProgress) => {
    state = { ...data, loading: false };
    notify();
  });

  return {
    subscribe(run) {
      subscribers.add(run);
      run(state);
      return () => {
        subscribers.delete(run);
        if (subscribers.size === 0) unsubscribeFn();
      };
    },
    unsubscribe: unsubscribeFn,
  };
}

export function subscribeWorkflow(workflowId: string): WorkflowStore {
  if (!uuidRegex.test(workflowId)) {
    throw new Error("Invalid workflow ID: must be a valid UUID");
  }

  const client = getForgeClient();
  const subscribers = new Set<
    (value: WorkflowProgress & { loading: boolean }) => void
  >();
  let state: WorkflowProgress & { loading: boolean } = {
    workflow_id: workflowId,
    status: "created" as WorkflowStatus,
    current_step: null,
    steps: [],
    output: null,
    error: null,
    loading: true,
  };

  const notify = () => subscribers.forEach((run) => run(state));

  const unsubscribeFn = client.subscribeWorkflow(
    workflowId,
    (data: WorkflowProgress) => {
      state = { ...data, loading: false };
      notify();
    },
  );

  return {
    subscribe(run) {
      subscribers.add(run);
      run(state);
      return () => {
        subscribers.delete(run);
        if (subscribers.size === 0) unsubscribeFn();
      };
    },
    unsubscribe: unsubscribeFn,
  };
}

export interface JobTracker<TArgs> extends Readable<JobProgress | null> {
  start: (args: TArgs) => Promise<string>;
  resume: (jobId: string, onNotFound?: () => void) => void;
  cleanup: () => void;
}

export interface WorkflowTracker<TArgs>
  extends Readable<WorkflowProgress | null> {
  start: (args: TArgs) => Promise<string>;
  resume: (workflowId: string, onNotFound?: () => void) => void;
  cleanup: () => void;
}

export function createJobTracker<TArgs>(
  jobType: string,
  apiUrl: string,
): JobTracker<TArgs> {
  const client = getForgeClient();
  const subscribers = new Set<(value: JobProgress | null) => void>();
  let state: JobProgress | null = null;
  let unsubscribeFn: (() => void) | null = null;

  const notify = () => subscribers.forEach((run) => run(state));

  const subscribeToJob = (jobId: string, onNotFound?: () => void) => {
    if (!uuidRegex.test(jobId)) {
      throw new Error("Invalid job ID: must be a valid UUID");
    }

    if (unsubscribeFn) {
      unsubscribeFn();
      unsubscribeFn = null;
    }

    state = {
      job_id: jobId,
      status: "pending" as JobStatus,
      progress_percent: null,
      progress_message: null,
      output: null,
      error: null,
    };
    notify();

    unsubscribeFn = client.subscribeJob(jobId, (data: JobProgress) => {
      if (data.status === "not_found") {
        // Clear state when job not found (e.g., stale localStorage)
        state = null;
        notify();
        onNotFound?.();
        return;
      }
      state = data;
      notify();
    });
  };

  return {
    subscribe(run) {
      subscribers.add(run);
      run(state);
      return () => {
        subscribers.delete(run);
      };
    },

    async start(args: TArgs): Promise<string> {
      const response = await fetch(`${apiUrl}/_api/jobs/${jobType}/dispatch`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ args: args || {} }),
      });

      const result = await response.json();
      if (result.error || !result.data?.job_id) {
        throw new Error(result.error?.message || "Failed to dispatch job");
      }

      const jobId = result.data.job_id;
      subscribeToJob(jobId);
      return jobId;
    },

    resume(jobId: string, onNotFound?: () => void) {
      subscribeToJob(jobId, onNotFound);
    },

    cleanup() {
      if (unsubscribeFn) {
        unsubscribeFn();
        unsubscribeFn = null;
      }
      state = null;
      notify();
    },
  };
}

export function createWorkflowTracker<TArgs>(
  workflowType: string,
  apiUrl: string,
): WorkflowTracker<TArgs> {
  const client = getForgeClient();
  const subscribers = new Set<(value: WorkflowProgress | null) => void>();
  let state: WorkflowProgress | null = null;
  let unsubscribeFn: (() => void) | null = null;

  const notify = () => subscribers.forEach((run) => run(state));

  const subscribeToWorkflow = (workflowId: string, onNotFound?: () => void) => {
    if (!uuidRegex.test(workflowId)) {
      throw new Error("Invalid workflow ID: must be a valid UUID");
    }

    if (unsubscribeFn) {
      unsubscribeFn();
      unsubscribeFn = null;
    }

    state = {
      workflow_id: workflowId,
      status: "created" as WorkflowStatus,
      current_step: null,
      steps: [],
      output: null,
      error: null,
    };
    notify();

    unsubscribeFn = client.subscribeWorkflow(
      workflowId,
      (data: WorkflowProgress) => {
        if (data.status === "not_found") {
          // Clear state when workflow not found (e.g., stale localStorage)
          state = null;
          notify();
          onNotFound?.();
          return;
        }
        state = data;
        notify();
      },
    );
  };

  return {
    subscribe(run) {
      subscribers.add(run);
      run(state);
      return () => {
        subscribers.delete(run);
      };
    },

    async start(args: TArgs): Promise<string> {
      const response = await fetch(
        `${apiUrl}/_api/workflows/${workflowType}/start`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input: args || {} }),
        },
      );

      const result = await response.json();
      if (result.error || !result.data?.workflow_id) {
        throw new Error(result.error?.message || "Failed to start workflow");
      }

      const workflowId = result.data.workflow_id;
      subscribeToWorkflow(workflowId);
      return workflowId;
    },

    resume(workflowId: string, onNotFound?: () => void) {
      subscribeToWorkflow(workflowId, onNotFound);
    },

    cleanup() {
      if (unsubscribeFn) {
        unsubscribeFn();
        unsubscribeFn = null;
      }
      state = null;
      notify();
    },
  };
}
