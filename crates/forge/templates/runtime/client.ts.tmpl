// Auto-generated by FORGE v{{version}} - DO NOT EDIT
// Regenerate with: forge generate

import type {
  ForgeError,
  ConnectionState,
  ForgeClientInterface,
  JobProgress,
  WorkflowProgress,
} from "./types.js";

export interface ForgeClientConfig {
  url: string;
  getToken?: () => string | null | Promise<string | null>;
  onAuthError?: (error: ForgeError) => void;
  timeout?: number;
}

interface RpcResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: ForgeError;
}

interface WsMessage {
  type: string;
  id?: string;
  data?: unknown;
  error?: ForgeError;
}

export class ForgeClientError extends Error {
  code: string;
  constructor(code: string, message: string) {
    super(message);
    this.name = "ForgeClientError";
    this.code = code;
  }
}

export class ForgeClient implements ForgeClientInterface {
  private config: ForgeClientConfig;
  private ws: WebSocket | null = null;
  private connectionState: ConnectionState = "disconnected";
  private subscriptions = new Map<string, (data: unknown) => void>();
  private pendingSubscriptions = new Map<
    string,
    { functionName: string; args: unknown }
  >();
  private connectionListeners = new Set<(state: ConnectionState) => void>();
  // Job/Workflow subscription tracking
  private jobCallbacks = new Map<string, (data: JobProgress) => void>();
  private workflowCallbacks = new Map<
    string,
    (data: WorkflowProgress) => void
  >();
  private pendingJobSubscriptions = new Map<string, string>(); // subId -> jobId
  private pendingWorkflowSubscriptions = new Map<string, string>(); // subId -> workflowId

  constructor(config: ForgeClientConfig) {
    this.config = config;
  }

  getConnectionState(): ConnectionState {
    return this.connectionState;
  }

  onConnectionStateChange(
    listener: (state: ConnectionState) => void,
  ): () => void {
    this.connectionListeners.add(listener);
    return () => this.connectionListeners.delete(listener);
  }

  async connect(): Promise<void> {
    if (this.ws?.readyState === WebSocket.OPEN) return;

    return new Promise((resolve) => {
      const wsUrl = this.config.url.replace(/^http/, "ws") + "/ws";
      this.setConnectionState("connecting");

      try {
        this.ws = new WebSocket(wsUrl);
      } catch {
        this.setConnectionState("disconnected");
        resolve();
        return;
      }

      this.ws.onopen = async () => {
        const token = await this.getToken();
        if (token) this.ws?.send(JSON.stringify({ type: "auth", token }));
        this.setConnectionState("connected");
        this.flushPendingSubscriptions();
        resolve();
      };

      this.ws.onerror = () => {
        this.setConnectionState("disconnected");
        resolve();
      };

      this.ws.onclose = () => this.setConnectionState("disconnected");
      this.ws.onmessage = (event) => this.handleMessage(event.data);
    });
  }

  disconnect(): void {
    this.ws?.close();
    this.ws = null;
    this.setConnectionState("disconnected");
    this.subscriptions.clear();
  }

  async call<T>(functionName: string, args: unknown): Promise<T> {
    const token = await this.getToken();
    const normalizedArgs =
      args && typeof args === "object" && Object.keys(args).length === 0
        ? null
        : args;

    const response = await fetch(`${this.config.url}/rpc/${functionName}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      },
      body: JSON.stringify(normalizedArgs),
    });

    const result: RpcResponse<T> = await response.json();
    if (!result.success || result.error) {
      const error = result.error || {
        code: "UNKNOWN",
        message: "Unknown error",
      };
      throw new ForgeClientError(error.code, error.message);
    }
    return result.data as T;
  }

  subscribe<T>(
    functionName: string,
    args: unknown,
    callback: (data: T) => void,
  ): () => void {
    const subscriptionId = Math.random().toString(36).substring(2, 15);
    this.subscriptions.set(subscriptionId, callback as (data: unknown) => void);

    const normalizedArgs =
      args && typeof args === "object" && Object.keys(args).length === 0
        ? null
        : args;

    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(
        JSON.stringify({
          type: "subscribe",
          id: subscriptionId,
          function: functionName,
          args: normalizedArgs,
        }),
      );
    } else {
      this.pendingSubscriptions.set(subscriptionId, {
        functionName,
        args: normalizedArgs,
      });
    }

    return () => {
      this.subscriptions.delete(subscriptionId);
      this.pendingSubscriptions.delete(subscriptionId);
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.send(
          JSON.stringify({ type: "unsubscribe", id: subscriptionId }),
        );
      }
    };
  }

  /** Subscribe to job progress updates. */
  subscribeJob(
    jobId: string,
    callback: (data: JobProgress) => void,
  ): () => void {
    const subId = `job_${jobId}_${Date.now()}`;
    this.jobCallbacks.set(subId, callback);
    this.pendingJobSubscriptions.set(subId, jobId);

    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(
        JSON.stringify({ type: "subscribe_job", id: subId, job_id: jobId }),
      );
    }

    return () => {
      this.jobCallbacks.delete(subId);
      this.pendingJobSubscriptions.delete(subId);
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({ type: "unsubscribe_job", id: subId }));
      }
    };
  }

  /** Subscribe to workflow progress updates. */
  subscribeWorkflow(
    workflowId: string,
    callback: (data: WorkflowProgress) => void,
  ): () => void {
    const subId = `workflow_${workflowId}_${Date.now()}`;
    this.workflowCallbacks.set(subId, callback);
    this.pendingWorkflowSubscriptions.set(subId, workflowId);

    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(
        JSON.stringify({
          type: "subscribe_workflow",
          id: subId,
          workflow_id: workflowId,
        }),
      );
    }

    return () => {
      this.workflowCallbacks.delete(subId);
      this.pendingWorkflowSubscriptions.delete(subId);
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.send(
          JSON.stringify({ type: "unsubscribe_workflow", id: subId }),
        );
      }
    };
  }

  private flushPendingSubscriptions(): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
    for (const [id, { functionName, args }] of this.pendingSubscriptions) {
      this.ws.send(
        JSON.stringify({ type: "subscribe", id, function: functionName, args }),
      );
    }
    this.pendingSubscriptions.clear();
    // Re-subscribe job subscriptions
    for (const [subId, jobId] of this.pendingJobSubscriptions) {
      this.ws.send(
        JSON.stringify({ type: "subscribe_job", id: subId, job_id: jobId }),
      );
    }
    // Re-subscribe workflow subscriptions
    for (const [subId, workflowId] of this.pendingWorkflowSubscriptions) {
      this.ws.send(
        JSON.stringify({
          type: "subscribe_workflow",
          id: subId,
          workflow_id: workflowId,
        }),
      );
    }
  }

  private async getToken(): Promise<string | null> {
    return this.config.getToken?.() ?? null;
  }

  private setConnectionState(state: ConnectionState): void {
    this.connectionState = state;
    this.connectionListeners.forEach((listener) => listener(state));
  }

  private handleMessage(data: string): void {
    try {
      const message = JSON.parse(data) as WsMessage & {
        job?: JobProgress;
        workflow?: WorkflowProgress;
      };
      if ((message.type === "data" || message.type === "delta") && message.id) {
        const callback = this.subscriptions.get(message.id);
        if (callback) callback(message.data);
      } else if (message.type === "job_update" && message.id && message.job) {
        const callback = this.jobCallbacks.get(message.id);
        if (callback) callback(message.job);
      } else if (
        message.type === "workflow_update" &&
        message.id &&
        message.workflow
      ) {
        const callback = this.workflowCallbacks.get(message.id);
        if (callback) callback(message.workflow);
      } else if (message.type === "error" && message.id) {
        // Handle subscription errors (e.g., job/workflow not found)
        const errorMessage = (message as { message?: string }).message || "Unknown error";
        const jobCallback = this.jobCallbacks.get(message.id);
        if (jobCallback) {
          jobCallback({
            job_id: "",
            status: "not_found",
            progress_percent: null,
            progress_message: null,
            output: null,
            error: errorMessage,
          });
          this.jobCallbacks.delete(message.id);
          this.pendingJobSubscriptions.delete(message.id);
        }
        const workflowCallback = this.workflowCallbacks.get(message.id);
        if (workflowCallback) {
          workflowCallback({
            workflow_id: "",
            status: "not_found",
            current_step: null,
            steps: [],
            output: null,
            error: errorMessage,
          });
          this.workflowCallbacks.delete(message.id);
          this.pendingWorkflowSubscriptions.delete(message.id);
        }
      }
    } catch {}
  }
}

export function createForgeClient(config: ForgeClientConfig): ForgeClient {
  return new ForgeClient(config);
}
