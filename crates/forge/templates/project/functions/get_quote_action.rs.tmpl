use forge::prelude::*;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetQuoteInput {
    pub category: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GetQuoteOutput {
    pub quote: String,
    pub author: String,
    pub category: String,
}

#[derive(Debug, Deserialize)]
struct ZenQuoteResponse {
    q: String,
    a: String,
}

/// Action demonstrating:
/// - External API calls (non-transactional)
/// - Timeout configuration
/// - HTTP client access via ctx.http()
/// - Structured logging
///
/// Actions differ from mutations:
/// - Not wrapped in a database transaction
/// - Can make external API calls
/// - May have side effects outside the database
#[forge::action(timeout = 60)]
pub async fn get_quote(ctx: &ActionContext, input: GetQuoteInput) -> Result<GetQuoteOutput> {
    let category = input.category.unwrap_or_else(|| "inspiration".to_string());

    tracing::info!(category = %category, "Fetching quote from external API");

    // Call ZenQuotes API (free, no auth required, ~1s response time)
    let response = ctx
        .http()
        .get("https://zenquotes.io/api/random")
        .send()
        .await
        .map_err(|e| ForgeError::Function(format!("HTTP request failed: {}", e)))?;

    if !response.status().is_success() {
        return Err(ForgeError::Function(format!(
            "API returned error status: {}",
            response.status()
        )));
    }

    let quotes: Vec<ZenQuoteResponse> = response
        .json()
        .await
        .map_err(|e| ForgeError::Function(format!("Failed to parse response: {}", e)))?;

    let quote_data = quotes
        .into_iter()
        .next()
        .ok_or_else(|| ForgeError::Function("No quote returned from API".to_string()))?;

    tracing::info!(author = %quote_data.a, "Quote fetched successfully");

    Ok(GetQuoteOutput {
        quote: quote_data.q,
        author: quote_data.a,
        category,
    })
}
