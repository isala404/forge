//! Example tests for FORGE applications.
//!
//! Run with: cargo test

use forge::prelude::*;

// Test ForgeError variants
#[test]
fn test_error_types() {
    let validation_err = ForgeError::Validation("invalid input".to_string());
    let not_found_err = ForgeError::NotFound("missing".to_string());

    assert!(matches!(validation_err, ForgeError::Validation(_)));
    assert!(matches!(not_found_err, ForgeError::NotFound(_)));
}

// Test Result handling
#[test]
fn test_result_handling() {
    fn get_value() -> Result<i32> {
        Ok(42)
    }
    let success = get_value();
    let failure: Result<i32> = Err(ForgeError::Validation("bad input".into()));

    assert!(success.is_ok());
    assert_eq!(success.unwrap(), 42);

    assert!(failure.is_err());
    assert!(matches!(failure, Err(ForgeError::Validation(_))));
}

// Helper: Check if JSON contains expected fields
fn json_contains(actual: &serde_json::Value, expected: &serde_json::Value) -> bool {
    match (actual, expected) {
        (serde_json::Value::Object(a), serde_json::Value::Object(e)) => e
            .iter()
            .all(|(k, v)| a.get(k).map(|av| json_contains(av, v)).unwrap_or(false)),
        (a, e) => a == e,
    }
}

// Test JSON matching helper
#[test]
fn test_json_matching() {
    let actual = serde_json::json!({
        "user": {
            "id": "123",
            "email": "test@example.com",
            "metadata": {
                "created": "2024-01-01",
                "verified": true
            }
        },
        "status": "active"
    });

    // Partial match - only check specific fields
    assert!(json_contains(
        &actual,
        &serde_json::json!({
            "status": "active"
        })
    ));

    // Nested partial match
    assert!(json_contains(
        &actual,
        &serde_json::json!({
            "user": {
                "email": "test@example.com"
            }
        })
    ));

    // Deep nested match
    assert!(json_contains(
        &actual,
        &serde_json::json!({
            "user": {
                "metadata": {
                    "verified": true
                }
            }
        })
    ));
}

// Test UUID generation
#[test]
fn test_uuid_generation() {
    let id1 = Uuid::new_v4();
    let id2 = Uuid::new_v4();
    assert_ne!(id1, id2);
}

// Test timestamp handling
#[test]
fn test_timestamp() {
    let now: Timestamp = Utc::now();
    let later = now + chrono::Duration::hours(1);
    assert!(later > now);
}

// Example: Testing a query function with database
// Requires TEST_DATABASE_URL environment variable
//
// #[tokio::test]
// async fn test_get_users_query() {
//     dotenvy::dotenv().ok();
//     let db_url = std::env::var("TEST_DATABASE_URL")
//         .expect("TEST_DATABASE_URL must be set");
//
//     let pool = sqlx::PgPool::connect(&db_url)
//         .await
//         .expect("Failed to connect to database");
//
//     let users: Vec<crate::models::User> = sqlx::query_as("SELECT * FROM users LIMIT 10")
//         .fetch_all(&pool)
//         .await
//         .expect("Query failed");
//
//     // Verify results
//     for user in &users {
//         assert!(!user.email.is_empty());
//     }
// }
