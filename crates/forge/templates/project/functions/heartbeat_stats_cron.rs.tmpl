use forge::prelude::*;

/// Scheduled cron job demonstrating:
/// - Cron schedule expression (every minute)
/// - Timezone configuration
/// - Delay detection with ctx.delay() and ctx.is_late()
/// - Structured logging with ctx.log.info/warn/error/debug
///
/// Note: Catch-up is disabled by default. If the server is down when a cron
/// should run, that execution is skipped. Enable with #[catch_up] if needed.
#[forge::cron("* * * * *")]
#[timezone = "UTC"]
pub async fn heartbeat_stats(ctx: &CronContext) -> Result<()> {
    let now = Utc::now();

    // Check if execution is delayed
    let delay = ctx.delay();
    if ctx.is_late() {
        ctx.log.warn(
            "Cron execution is late",
            serde_json::json!({
                "delay_seconds": delay.num_seconds(),
                "scheduled_time": ctx.scheduled_time.to_rfc3339(),
            }),
        );
    }

    // Log start with structured context
    ctx.log.info(
        "Running heartbeat stats update",
        serde_json::json!({
            "run_id": ctx.run_id.to_string(),
            "timezone": &ctx.timezone,
        }),
    );

    // Update last heartbeat timestamp
    sqlx::query(
        "INSERT INTO app_stats (id, stat_name, stat_value, updated_at)
         VALUES ('heartbeat', 'last_heartbeat', $1, NOW())
         ON CONFLICT (id) DO UPDATE SET stat_value = $1, updated_at = NOW()",
    )
    .bind(now.to_rfc3339())
    .execute(ctx.db())
    .await?;

    // Get user count
    let user_count: (i64,) = sqlx::query_as("SELECT COUNT(*) FROM users")
        .fetch_one(ctx.db())
        .await?;

    sqlx::query(
        "INSERT INTO app_stats (id, stat_name, stat_value, updated_at)
         VALUES ('user_count', 'total_users', $1, NOW())
         ON CONFLICT (id) DO UPDATE SET stat_value = $1, updated_at = NOW()",
    )
    .bind(user_count.0.to_string())
    .execute(ctx.db())
    .await?;

    // Log completion with stats
    ctx.log.debug(
        "Heartbeat stats updated successfully",
        serde_json::json!({
            "user_count": user_count.0,
            "execution_time_ms": (Utc::now() - ctx.execution_time).num_milliseconds(),
        }),
    );

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Duration;

    // Cron test contexts simulate scheduled execution timing, late detection,
    // catch-up runs, and timezone handling.

    #[tokio::test]
    async fn test_cron_on_time() {
        let now = Utc::now();
        let ctx = TestCronContext::builder("heartbeat_stats")
            .scheduled_at(now)
            .build();

        assert_eq!(ctx.cron_name, "heartbeat_stats");
        assert!(!ctx.is_late());
        assert!(!ctx.is_catch_up);
    }

    #[tokio::test]
    async fn test_cron_late_detection() {
        let scheduled = Utc::now() - Duration::minutes(5);
        let ctx = TestCronContext::builder("heartbeat_stats")
            .scheduled_at(scheduled)
            .build();

        assert!(ctx.is_late());
        assert!(ctx.delay() >= Duration::minutes(4));
    }

    #[tokio::test]
    async fn test_cron_catch_up() {
        let ctx = TestCronContext::builder("heartbeat_stats")
            .as_catch_up()
            .build();

        assert!(ctx.is_catch_up);
    }

    #[tokio::test]
    async fn test_cron_timezone() {
        let ctx = TestCronContext::builder("heartbeat_stats")
            .with_timezone("America/New_York")
            .build();

        assert_eq!(ctx.timezone, "America/New_York");
    }

    #[tokio::test]
    async fn test_cron_logging() {
        let ctx = TestCronContext::builder("heartbeat_stats").build();

        ctx.log.info("Starting stats update");
        ctx.log.warn("Slow query detected");
        ctx.log.debug("Query completed");

        let entries = ctx.log.entries();
        assert_eq!(entries.len(), 3);
        assert_eq!(entries[0].level, "info");
        assert_eq!(entries[1].level, "warn");
        assert_eq!(entries[2].level, "debug");
    }
}
