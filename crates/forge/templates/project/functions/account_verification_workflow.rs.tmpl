use forge::prelude::*;
use std::time::Duration;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountVerificationInput {
    pub user_id: String,
    pub email: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountVerificationOutput {
    pub verified: bool,
    pub token: String,
    pub verification_method: String,
}

/// Durable workflow demonstrating:
/// - Manual step tracking for resumable execution
/// - Suspension with ctx.sleep() (survives server restarts)
/// - Resumption detection with ctx.is_resumed()
/// - Deterministic time with ctx.workflow_time()
/// - Step state persistence with is_step_completed/record_step_*
///
/// For parallel execution, see ctx.parallel() in the docs.
/// For fluent API, see ctx.step(name, fn).compensate(fn).timeout().run()
#[forge::workflow]
#[version = 1]
#[timeout = "24h"]
pub async fn account_verification(
    ctx: &WorkflowContext,
    input: AccountVerificationInput,
) -> Result<AccountVerificationOutput> {
    // Check if we're resuming from a previous suspension
    if ctx.is_resumed() {
        tracing::info!(
            workflow_id = %ctx.run_id,
            "Resuming verification workflow from suspended state"
        );
    } else {
        tracing::info!(
            workflow_id = %ctx.run_id,
            user_id = %input.user_id,
            "Starting new verification workflow"
        );
    }

    // Use deterministic workflow time for reproducible behavior on replay
    let workflow_start = ctx.workflow_time();
    tracing::debug!(workflow_time = %workflow_start, "Workflow time recorded");

    // Step 1: Generate verification token (with resumption support)
    let token = if ctx.is_step_completed("generate_token") {
        ctx.get_step_result::<String>("generate_token")
            .unwrap_or_else(|| format!("verify_{}", Uuid::new_v4()))
    } else {
        ctx.record_step_start("generate_token");
        tracing::info!("Generating verification token");
        tokio::time::sleep(Duration::from_millis(200)).await;
        let token = format!("verify_{}", Uuid::new_v4());
        ctx.record_step_complete("generate_token", serde_json::json!(token));
        token
    };

    // Step 2: Store token in database
    if !ctx.is_step_completed("store_token") {
        ctx.record_step_start("store_token");
        tracing::info!("Storing verification token in database");
        tokio::time::sleep(Duration::from_millis(200)).await;
        // In production: INSERT INTO verification_tokens ...
        ctx.record_step_complete("store_token", serde_json::json!({"stored": true}));
    }

    // Step 3: Send verification email
    if !ctx.is_step_completed("send_email") {
        ctx.record_step_start("send_email");
        tracing::info!(email = %input.email, "Sending verification email");
        tokio::time::sleep(Duration::from_millis(300)).await;
        // In production: call email service API
        ctx.record_step_complete("send_email", serde_json::json!({"sent": true}));
    }

    // Step 4: Durable sleep - workflow suspends and resumes after delay
    // This is the key differentiator: ctx.sleep() survives server restarts!
    // The workflow will be suspended in the database and resumed by the scheduler.
    if !ctx.is_step_completed("wait_period") {
        ctx.record_step_start("wait_period");
        tracing::info!("Entering durable sleep (2 seconds)");

        // Use ctx.sleep() for durable waiting - workflow suspends here
        // In production, you might sleep for hours or days
        ctx.sleep(Duration::from_secs(2)).await?;

        ctx.record_step_complete("wait_period", serde_json::json!({"waited": true}));
        tracing::info!("Resumed from durable sleep");
    }

    // Step 5: Mark account as verified
    if !ctx.is_step_completed("mark_verified") {
        ctx.record_step_start("mark_verified");
        tracing::info!(user_id = %input.user_id, "Marking account as verified");
        tokio::time::sleep(Duration::from_millis(200)).await;
        // In production: UPDATE users SET verified = true WHERE id = $1
        ctx.record_step_complete("mark_verified", serde_json::json!(true));
    }

    tracing::info!(
        workflow_id = %ctx.run_id,
        "Verification workflow completed"
    );

    Ok(AccountVerificationOutput {
        verified: true,
        token,
        verification_method: "email".to_string(),
    })
}

// ============================================================================
// ADVANCED PATTERNS (for reference - uncomment to use)
// ============================================================================

// Parallel step execution example:
// let results = ctx.parallel()
//     .step("send_email", || async { Ok(serde_json::json!({"sent": true})) })
//     .step("send_sms", || async { Ok(serde_json::json!({"sent": true})) })
//     .run()
//     .await?;
// let email_result: serde_json::Value = results.get("send_email")?;

// Fluent step API with compensation (saga pattern):
// let token: String = ctx
//     .step("generate_token", || async {
//         Ok(format!("verify_{}", Uuid::new_v4()))
//     })
//     .compensate(|token| async move {
//         tracing::warn!(token = %token, "Compensating: invalidating token");
//         Ok(())
//     })
//     .timeout(Duration::from_secs(30))
//     .optional()  // Won't fail workflow if this step fails
//     .run()
//     .await?;

// Wait for external event with timeout:
// let event_data: serde_json::Value = ctx
//     .wait_for_event("email_confirmed", Some(Duration::from_hours(24)))
//     .await?;
