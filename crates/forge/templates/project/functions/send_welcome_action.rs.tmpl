use forge::prelude::*;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendWelcomeInput {
    pub user_id: Uuid,
    pub email: String,
    pub name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SendWelcomeOutput {
    pub sent: bool,
    pub message_id: String,
}

/// Action demonstrating:
/// - External API calls (non-transactional)
/// - Timeout configuration
/// - HTTP client access via ctx.http()
/// - Structured logging
///
/// Actions differ from mutations:
/// - Not wrapped in a database transaction
/// - Can make external API calls
/// - May have side effects outside the database
#[forge::action(timeout = 60)]
pub async fn send_welcome_email(
    _ctx: &ActionContext,
    input: SendWelcomeInput,
) -> Result<SendWelcomeOutput> {
    tracing::info!(
        user_id = %input.user_id,
        email = %input.email,
        "Sending welcome email"
    );

    // Example: Call external email service API
    // Using ctx.http() for HTTP requests
    //
    // let response = ctx.http()
    //     .post("https://api.sendgrid.com/v3/mail/send")
    //     .bearer_auth(std::env::var("SENDGRID_API_KEY")?)
    //     .json(&serde_json::json!({
    //         "personalizations": [{
    //             "to": [{"email": input.email, "name": input.name}]
    //         }],
    //         "from": {"email": "noreply@example.com"},
    //         "subject": "Welcome!",
    //         "content": [{
    //             "type": "text/plain",
    //             "value": format!("Welcome to our platform, {}!", input.name)
    //         }]
    //     }))
    //     .send()
    //     .await
    //     .map_err(|e| ForgeError::Action(e.to_string()))?;
    //
    // if !response.status().is_success() {
    //     return Err(ForgeError::Action("Email send failed".into()));
    // }

    // Simulated delay for demo
    tokio::time::sleep(std::time::Duration::from_millis(100)).await;

    let message_id = format!("msg_{}", Uuid::new_v4());

    tracing::info!(
        message_id = %message_id,
        user_id = %input.user_id,
        "Welcome email sent successfully"
    );

    Ok(SendWelcomeOutput {
        sent: true,
        message_id,
    })
}

// Example of auth-protected action (uncomment to use):
// #[forge::action(require_auth, timeout = 120)]
// pub async fn send_admin_notification(
//     ctx: &ActionContext,
//     input: AdminNotificationInput,
// ) -> Result<AdminNotificationOutput> {
//     // Only authenticated users can call this action
//     let user_id = ctx.require_user_id()?;
//     tracing::info!(user_id = %user_id, "Sending admin notification");
//     // ... implementation
// }
