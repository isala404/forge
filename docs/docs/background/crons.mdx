---
sidebar_position: 2
title: Cron Jobs
description: Scheduled recurring tasks with timezone support, catch-up runs, and structured logging
---

# Cron Jobs

Crons are scheduled tasks that run automatically at specified intervals. Perfect for:

- Daily reports
- Hourly cleanups
- Weekly digests
- Database maintenance
- Syncing external data

## Creating a Cron

```rust
use forge::prelude::*;

#[forge::cron]
#[schedule = "0 9 * * *"]  // Every day at 9 AM
pub async fn daily_summary(ctx: &CronContext) -> Result<()> {
    let yesterday = Utc::now() - chrono::Duration::days(1);

    // Get yesterday's stats
    let stats: (i64, i64) = sqlx::query_as(r#"
        SELECT
            COUNT(*) as total,
            COUNT(*) FILTER (WHERE completed) as done
        FROM tasks
        WHERE created_at >= $1
    "#)
    .bind(yesterday)
    .fetch_one(ctx.db())
    .await?;

    tracing::info!("Daily summary: {} tasks, {} completed", stats.0, stats.1);

    // Send email, Slack notification, etc.
    Ok(())
}
```

The macro generates `DailySummaryCron` which implements the `ForgeCron` trait.

## Cron Attributes

| Attribute | Example | Description |
|-----------|---------|-------------|
| `schedule` | `#[schedule = "0 * * * *"]` | Cron expression (required) |
| `timezone` | `#[timezone = "America/New_York"]` | Timezone for schedule |
| `timeout` | `#[timeout = "10m"]` | Max execution time |
| `enabled` | `#[enabled = false]` | Disable without removing |
| `catch_up` | `#[catch_up]` | Enable catching up missed runs |
| `catch_up_limit` | `#[catch_up_limit = 5]` | Max number of catch-up runs (default: 10) |

## Schedule Expressions

FORGE uses standard cron expressions:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ minute (0 - 59)
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ hour (0 - 23)
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ day of month (1 - 31)
â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ month (1 - 12)
â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ day of week (0 - 6, Sun = 0)
â”‚ â”‚ â”‚ â”‚ â”‚
* * * * *
```

### Common Schedules

| Expression | Description |
|------------|-------------|
| `* * * * *` | Every minute |
| `0 * * * *` | Every hour |
| `0 0 * * *` | Every day at midnight |
| `0 9 * * 1-5` | Weekdays at 9 AM |
| `0 0 * * 0` | Every Sunday at midnight |
| `0 0 1 * *` | First of every month |
| `*/15 * * * *` | Every 15 minutes |
| `0 */2 * * *` | Every 2 hours |

## CronContext

The context provides access to execution info and utilities:

```rust
pub struct CronContext {
    pub run_id: Uuid,                      // Unique run ID
    pub cron_name: String,                 // Name of this cron
    pub scheduled_time: DateTime<Utc>,     // When it was scheduled to run
    pub execution_time: DateTime<Utc>,     // When execution actually started
    pub timezone: String,                  // Timezone of the cron
    pub is_catch_up: bool,                 // Whether this is a catch-up run
    pub log: CronLog,                      // Structured logger
}

impl CronContext {
    // Database access
    fn db(&self) -> &PgPool;

    // HTTP client for external APIs
    fn http(&self) -> &Client;

    // Get the delay between scheduled and actual execution time
    fn delay(&self) -> chrono::Duration;

    // Check if execution is late (more than 1 minute delay)
    fn is_late(&self) -> bool;
}
```

### Execution Timing

Use `delay()` and `is_late()` to monitor execution timing:

```rust
#[forge::cron]
#[schedule = "0 * * * *"]
pub async fn hourly_task(ctx: &CronContext) -> Result<()> {
    if ctx.is_late() {
        ctx.log.warn(
            "Cron running late",
            serde_json::json!({
                "delay_seconds": ctx.delay().num_seconds()
            })
        );
    }

    // Your logic here
    Ok(())
}
```

## Catch-Up Runs

When your application is down or a cron cannot run at its scheduled time, you can configure catch-up behavior to process missed runs:

```rust
#[forge::cron]
#[schedule = "0 * * * *"]  // Every hour
#[catch_up]                 // Enable catch-up for missed runs
#[catch_up_limit = 5]       // Process at most 5 missed runs
pub async fn hourly_report(ctx: &CronContext) -> Result<()> {
    if ctx.is_catch_up {
        ctx.log.info(
            "Processing missed run",
            serde_json::json!({
                "scheduled_for": ctx.scheduled_time.to_rfc3339(),
                "running_at": ctx.execution_time.to_rfc3339()
            })
        );
    }

    // Generate report for the scheduled time, not current time
    let report_time = ctx.scheduled_time;
    generate_hourly_report(ctx.db(), report_time).await?;

    Ok(())
}
```

### How Catch-Up Works

1. When a cron with `#[catch_up]` starts, FORGE checks for missed scheduled times
2. Up to `catch_up_limit` missed runs are queued (default: 10)
3. Each catch-up run has `ctx.is_catch_up = true`
4. Use `ctx.scheduled_time` for time-sensitive logic, not `Utc::now()`

### When to Use Catch-Up

| Use Case | Catch-Up | Reason |
|----------|----------|--------|
| Billing calculations | Yes | Every period must be processed |
| Daily reports | Yes | Historical data matters |
| Health checks | No | Only current state matters |
| Cache warming | No | Stale cache not useful |
| Notifications | Maybe | Depends on urgency |

## Structured Logging

`CronLog` provides structured logging with automatic cron context:

```rust
#[forge::cron]
#[schedule = "0 * * * *"]
pub async fn process_queue(ctx: &CronContext) -> Result<()> {
    let items = fetch_pending_items(ctx.db()).await?;

    ctx.log.info("Processing queue", serde_json::json!({
        "item_count": items.len()
    }));

    for item in &items {
        match process_item(item).await {
            Ok(_) => {
                ctx.log.debug("Item processed", serde_json::json!({
                    "item_id": item.id
                }));
            }
            Err(e) => {
                ctx.log.error("Item failed", serde_json::json!({
                    "item_id": item.id,
                    "error": e.to_string()
                }));
            }
        }
    }

    ctx.log.info("Queue processing complete", serde_json::json!({
        "processed": items.len()
    }));

    Ok(())
}
```

### CronLog Methods

| Method | Level | Use Case |
|--------|-------|----------|
| `log.debug()` | DEBUG | Detailed diagnostic info |
| `log.info()` | INFO | Normal operations |
| `log.warn()` | WARN | Potential issues, handled errors |
| `log.error()` | ERROR | Failures requiring attention |

All log methods automatically include `cron_name` in the structured output.

## Timezone Support

By default, crons use UTC. Specify a timezone for local scheduling:

```rust
#[forge::cron]
#[schedule = "0 9 * * *"]
#[timezone = "America/Los_Angeles"]  // 9 AM Pacific
pub async fn west_coast_report(ctx: &CronContext) -> Result<()> {
    // Runs at 9 AM Pacific, regardless of daylight saving
    Ok(())
}

#[forge::cron]
#[schedule = "0 18 * * 1-5"]
#[timezone = "Europe/London"]  // 6 PM London
pub async fn uk_end_of_day(ctx: &CronContext) -> Result<()> {
    // Runs at 6 PM UK time on weekdays
    Ok(())
}
```

## Practical Examples

### Database Cleanup

```rust
#[forge::cron]
#[schedule = "0 3 * * *"]  // 3 AM daily
#[timeout = "30m"]
pub async fn cleanup_old_data(ctx: &CronContext) -> Result<()> {
    let threshold = Utc::now() - chrono::Duration::days(90);

    // Delete old sessions
    let sessions = sqlx::query("DELETE FROM sessions WHERE created_at < $1")
        .bind(threshold)
        .execute(ctx.db())
        .await?;

    // Delete old audit logs
    let logs = sqlx::query("DELETE FROM audit_logs WHERE created_at < $1")
        .bind(threshold)
        .execute(ctx.db())
        .await?;

    tracing::info!(
        "Cleanup: {} sessions, {} logs deleted",
        sessions.rows_affected(),
        logs.rows_affected()
    );

    Ok(())
}
```

### External API Sync

```rust
#[derive(Deserialize)]
struct ExchangeRates {
    rates: HashMap<String, f64>,
}

#[forge::cron]
#[schedule = "0 */6 * * *"]  // Every 6 hours
pub async fn sync_exchange_rates(ctx: &CronContext) -> Result<()> {
    // Fetch latest rates
    let rates: ExchangeRates = ctx.http()
        .get("https://api.exchangerate.host/latest?base=USD")
        .send()
        .await?
        .json()
        .await?;

    // Update database
    for (currency, rate) in rates.rates {
        sqlx::query(r#"
            INSERT INTO exchange_rates (currency, rate, updated_at)
            VALUES ($1, $2, NOW())
            ON CONFLICT (currency) DO UPDATE
            SET rate = $2, updated_at = NOW()
        "#)
        .bind(&currency)
        .bind(rate)
        .execute(ctx.db())
        .await?;
    }

    tracing::info!("Updated {} exchange rates", rates.rates.len());
    Ok(())
}
```

### Weekly Digest Email

```rust
#[forge::cron]
#[schedule = "0 9 * * 1"]  // Every Monday at 9 AM
#[timezone = "America/New_York"]
pub async fn weekly_digest(ctx: &CronContext) -> Result<()> {
    let week_ago = Utc::now() - chrono::Duration::days(7);

    // Get users who want digests
    let users: Vec<(Uuid, String)> = sqlx::query_as(r#"
        SELECT id, email FROM users
        WHERE digest_enabled = true
    "#)
    .fetch_all(ctx.db())
    .await?;

    for (user_id, email) in users {
        // Get user's weekly stats
        let stats: (i64, i64) = sqlx::query_as(r#"
            SELECT
                COUNT(*) as created,
                COUNT(*) FILTER (WHERE completed) as completed
            FROM tasks
            WHERE user_id = $1 AND created_at >= $2
        "#)
        .bind(user_id)
        .bind(week_ago)
        .fetch_one(ctx.db())
        .await?;

        // Dispatch email job
        ctx.dispatch_job("send_digest_email", serde_json::json!({
            "email": email,
            "tasks_created": stats.0,
            "tasks_completed": stats.1,
        })).await?;
    }

    tracing::info!("Queued {} weekly digest emails", users.len());
    Ok(())
}
```

### Health Check

```rust
#[forge::cron]
#[schedule = "*/5 * * * *"]  // Every 5 minutes
#[timeout = "30s"]
pub async fn health_check(ctx: &CronContext) -> Result<()> {
    // Check database
    let db_ok = sqlx::query("SELECT 1")
        .fetch_one(ctx.db())
        .await
        .is_ok();

    // Check external service
    let api_ok = ctx.http()
        .get("https://api.example.com/health")
        .timeout(std::time::Duration::from_secs(5))
        .send()
        .await
        .map(|r| r.status().is_success())
        .unwrap_or(false);

    if !db_ok || !api_ok {
        tracing::error!(db = db_ok, api = api_ok, "Health check failed");
        // Could trigger an alert here
    }

    Ok(())
}
```

## Registering Crons

```rust
Forge::builder()
    .cron_registry_mut()
    .register::<DailySummaryCron>()
    .register::<CleanupOldDataCron>()
    .register::<SyncExchangeRatesCron>()
    .register::<WeeklyDigestCron>()
    .register::<HealthCheckCron>()
    // ...
```

## Cron Execution

```
                    Scheduler
                        â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â–¼           â–¼           â–¼
        Worker 1    Worker 2    Worker 3
            â”‚
            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Check: Is it â”‚  â”€â”€â”€â–º No â”€â”€â”€â–º Skip
    â”‚ time to run? â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
           Yes
            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Acquire lock â”‚  â”€â”€â”€â–º Fail â”€â”€â”€â–º Another worker got it
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
         Success
            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Run cron    â”‚
    â”‚  function    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚
            â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Update last  â”‚
    â”‚ run time     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Only one worker runs each cron, even in a multi-worker deployment.

## Database Schema

```sql
CREATE TABLE forge_crons (
    name VARCHAR(255) PRIMARY KEY,
    schedule VARCHAR(100) NOT NULL,
    timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',
    enabled BOOLEAN NOT NULL DEFAULT true,
    last_run TIMESTAMPTZ,
    next_run TIMESTAMPTZ,
    last_error TEXT,
    consecutive_failures INTEGER NOT NULL DEFAULT 0
);
```

## Monitoring

View cron status in the dashboard at `http://localhost:8080/_dashboard/crons`:

- Last run time
- Next scheduled run
- Success/failure history
- Error messages
- Enable/disable toggle

## Error Handling

Failed crons are logged but don't retry automatically (unlike jobs). Use proper error handling:

```rust
#[forge::cron]
#[schedule = "0 * * * *"]
pub async fn risky_operation(ctx: &CronContext) -> Result<()> {
    match do_something_risky().await {
        Ok(_) => {
            tracing::info!("Risky operation succeeded");
        }
        Err(e) => {
            tracing::error!("Risky operation failed: {}", e);
            // Could dispatch an alert job
            ctx.dispatch_job("send_alert", serde_json::json!({
                "type": "cron_failure",
                "cron": "risky_operation",
                "error": e.to_string(),
            })).await?;
        }
    }

    Ok(())
}
```

## What's Next?

<div className="row">
  <div className="col col--6">
    <a className="card" href="/background/workflows">
      <div className="card__header">
        <h3>ðŸ”„ Workflows</h3>
      </div>
      <div className="card__body">
        Multi-step processes with compensation
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a className="card" href="/background/jobs">
      <div className="card__header">
        <h3>ðŸ“‹ Background Jobs</h3>
      </div>
      <div className="card__body">
        One-off background tasks
      </div>
    </a>
  </div>
</div>
