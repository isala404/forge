---
sidebar_position: 5
title: WorkflowContext
description: API reference for WorkflowContext
---

# WorkflowContext

The `WorkflowContext` is passed to workflow functions. It provides step management, database access, and workflow metadata.

## Definition

```rust
pub struct WorkflowContext {
    pub run_id: Uuid,
    pub workflow_name: String,
    pub version: u32,
    pub started_at: DateTime<Utc>,
    pub auth: AuthContext,
}

impl WorkflowContext {
    // Database and HTTP
    pub fn db(&self) -> &PgPool;
    pub fn http(&self) -> &Client;

    // Step execution
    pub fn step<T, F, Fut>(&self, name: &str, f: F) -> StepRunner<T>;
    pub fn parallel(&self) -> ParallelBuilder;
    pub fn get_step_result<T: DeserializeOwned>(&self, name: &str) -> Option<T>;
    pub fn is_step_completed(&self, name: &str) -> bool;
    pub fn is_step_started(&self, name: &str) -> bool;

    // Manual step tracking
    pub fn record_step_start(&self, name: &str);
    pub fn record_step_complete(&self, name: &str, result: Value);
    pub async fn record_step_complete_async(&self, name: &str, result: Value);

    // Durable execution
    pub async fn sleep(&self, duration: Duration) -> Result<()>;
    pub async fn sleep_until(&self, wake_at: DateTime<Utc>) -> Result<()>;
    pub async fn wait_for_event(&self, event_name: &str, timeout: Option<Duration>) -> Result<WorkflowEvent>;

    // Time and dispatch
    pub fn workflow_time(&self) -> DateTime<Utc>;
    pub fn elapsed(&self) -> chrono::Duration;
    pub async fn dispatch_job(&self, job_type: &str, input: Value) -> Result<Uuid>;
}
```

## Fields

| Field | Type | Description |
|-------|------|-------------|
| `run_id` | `Uuid` | Unique identifier for this workflow execution |
| `workflow_name` | `String` | Name of the workflow type |
| `version` | `u32` | Workflow version number |
| `started_at` | `DateTime<Utc>` | When the workflow started |
| `auth` | `AuthContext` | Authentication context from the request |

## Methods

### `db()`

Returns the PostgreSQL connection pool.

```rust
let user: User = sqlx::query_as("SELECT * FROM users WHERE id = $1")
    .bind(user_id)
    .fetch_one(ctx.db())
    .await?;
```

### `http()`

Returns an HTTP client for external API calls.

```rust
let response = ctx.http()
    .post("https://api.stripe.com/v1/charges")
    .bearer_auth(&api_key)
    .json(&charge_data)
    .send()
    .await?;
```

### `step()`

Creates a step builder for defining workflow steps.

```rust
let result = ctx.step("charge_payment")
    .run(|| charge_payment(&input))
    .compensate(|| refund_payment(&input))
    .await?;
```

**Returns:** `StepBuilder` - A builder for configuring the step.

### `get_step_output()`

Retrieves the output from a previously completed step.

```rust
// In a later step, get output from earlier step
let customer_id: String = ctx.get_step_output("create_customer")
    .ok_or(ForgeError::Internal("Missing customer ID".into()))?;
```

### `dispatch_job()`

Dispatches a background job from within the workflow.

```rust
ctx.dispatch_job("send_notification", serde_json::json!({
    "user_id": user_id,
    "message": "Your order is complete!",
})).await?;
```

### `sleep()`

Suspends the workflow for a specified duration. The workflow is persisted and resumes automatically.

```rust
use std::time::Duration;

// Pause for 24 hours
ctx.sleep(Duration::from_secs(86400)).await?;

// Continue after 24 hours
ctx.step("delayed_action", || async {
    perform_delayed_action().await
}).run().await?;
```

**Note:** No resources are consumed while sleeping. The `WorkflowScheduler` polls the database and resumes workflows when their `wake_at` time is reached.

### `sleep_until()`

Suspends the workflow until a specific point in time.

```rust
// Wait until a specific time
let next_monday = calculate_next_monday_9am();
ctx.sleep_until(next_monday).await?;
```

### `wait_for_event()`

Suspends the workflow until an external event is received or timeout occurs.

```rust
// Wait up to 48 hours for an approval event
let event = ctx.wait_for_event(
    "approval_response",
    Some(Duration::from_secs(48 * 3600))
).await?;

// Access event data
if let Some(payload) = event.payload {
    let approved = payload.get("approved").and_then(|v| v.as_bool());
    // Handle approval...
}
```

**WorkflowEvent fields:**
- `id: Uuid` - Event unique identifier
- `event_name: String` - Name of the event
- `correlation_id: String` - Workflow run ID (as string)
- `payload: Option<serde_json::Value>` - Event data
- `created_at: DateTime<Utc>` - When event was sent

### `parallel()`

Creates a builder for executing multiple steps concurrently.

```rust
let results = ctx.parallel()
    .step("task_a", || async { do_task_a().await })
    .step("task_b", || async { do_task_b().await })
    .step_with_compensate(
        "task_c",
        || async { do_task_c().await },
        |result| async move { undo_task_c(result).await }
    )
    .run()
    .await?;

// Get typed results
let a: TypeA = results.get("task_a")?;
let b: TypeB = results.get("task_b")?;
```

### `workflow_time()`

Returns deterministic time for replay consistency. Use instead of `Utc::now()`.

```rust
// Deterministic - same value on replay
let expires_at = ctx.workflow_time() + Duration::hours(24);
```

### `is_step_completed()`

Checks if a step has already been completed (for manual resumption logic).

```rust
if !ctx.is_step_completed("custom_step") {
    // Step hasn't run yet
}
```

### `is_step_started()`

Checks if a step has been started (running, completed, or failed). Use this to guard steps that should only execute once, even across workflow suspension and resumption.

```rust
if !ctx.is_step_started("custom_step") {
    ctx.record_step_start("custom_step");
    // Do work...
    ctx.record_step_complete("custom_step", result);
}
```

### `record_step_start()`

Manually records that a step has started. This is idempotent - if the step is already running or beyond (completed/failed), this is a no-op. This prevents race conditions when resuming workflows.

```rust
ctx.record_step_start("manual_step");
```

### `record_step_complete()`

Records step completion with a result. Uses fire-and-forget database persistence.

```rust
ctx.record_step_complete("manual_step", serde_json::json!({
    "processed": 100
}));
```

### `record_step_complete_async()`

Records step completion and awaits database persistence. Use this after `sleep()` calls to ensure the step is marked complete before suspension.

```rust
// After durable sleep, use async version to ensure DB persistence
ctx.sleep(Duration::from_secs(3600)).await?;
ctx.record_step_complete_async("wait_period", serde_json::json!({})).await;
```

## StepBuilder

The `StepBuilder` configures individual workflow steps:

```rust
pub struct StepBuilder {
    // Internal fields
}

impl StepBuilder {
    // Set step timeout
    pub fn timeout(self, duration: Duration) -> Self;

    // Set number of retries
    pub fn retries(self, count: u32) -> Self;

    // Set backoff strategy
    pub fn backoff(self, strategy: BackoffStrategy) -> Self;

    // Define the step execution
    pub fn run<F, Fut, T>(self, f: F) -> StepRunner<T>
    where
        F: FnOnce() -> Fut,
        Fut: Future<Output = Result<T>>;
}
```

### Step with Compensation

```rust
ctx.step("reserve_inventory")
    .run(|| reserve_items(&order))
    .compensate(|reservation| release_items(reservation))
    .await?;
```

### Step without Compensation

```rust
ctx.step("send_email")
    .run(|| send_confirmation(&user))
    .await?;
```

### Step with Configuration

```rust
ctx.step("call_external_api")
    .timeout(Duration::from_secs(30))
    .retries(3)
    .backoff(BackoffStrategy::Exponential)
    .run(|| external_api_call(&data))
    .compensate(|| rollback_external(&data))
    .await?;
```

## Complete Example

```rust
use forge::prelude::*;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderInput {
    pub user_id: Uuid,
    pub items: Vec<OrderItem>,
    pub payment_method_id: String,
    pub shipping_address: Address,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderResult {
    pub order_id: Uuid,
    pub tracking_number: String,
}

#[forge::workflow]
#[timeout = "30m"]
pub async fn process_order(ctx: &WorkflowContext, input: OrderInput) -> Result<OrderResult> {
    // Step 1: Create order record
    let order = ctx.step("create_order")
        .run(|| create_order_record(ctx.db(), &input))
        .compensate(|order| cancel_order(ctx.db(), order.id))
        .await?;

    // Step 2: Reserve inventory
    let reservation = ctx.step("reserve_inventory")
        .timeout(Duration::from_secs(30))
        .run(|| reserve_inventory(&input.items))
        .compensate(|res| release_inventory(res))
        .await?;

    // Step 3: Charge payment
    let payment = ctx.step("charge_payment")
        .retries(3)
        .run(|| charge_payment(&input.payment_method_id, order.total))
        .compensate(|payment| refund_payment(payment.id))
        .await?;

    // Step 4: Create shipment
    let shipment = ctx.step("create_shipment")
        .run(|| create_shipment(&order, &input.shipping_address))
        .compensate(|shipment| cancel_shipment(shipment.id))
        .await?;

    // Step 5: Update order status (no compensation needed)
    ctx.step("finalize_order")
        .run(|| {
            update_order_status(ctx.db(), order.id, OrderStatus::Processing)
        })
        .await?;

    // Step 6: Send confirmation (async, no compensation)
    ctx.dispatch_job("send_order_confirmation", serde_json::json!({
        "order_id": order.id,
        "user_id": input.user_id,
    })).await?;

    Ok(OrderResult {
        order_id: order.id,
        tracking_number: shipment.tracking_number,
    })
}
```

## Compensation Flow

When a step fails, compensation runs in reverse order:

```
Step 1: create_order    → Success (saved)
Step 2: reserve_inventory → Success (saved)
Step 3: charge_payment   → Success (saved)
Step 4: create_shipment  → FAILED!
                            │
                            ▼
                   Begin Compensation
                            │
        ┌───────────────────┼───────────────────┐
        ▼                   ▼                   ▼
  refund_payment     release_inventory    cancel_order
   (undo step 3)      (undo step 2)      (undo step 1)
```

## See Also

- [Workflows](/background/workflows) - Full workflows guide
- [JobContext](/api/job-context) - For background jobs
