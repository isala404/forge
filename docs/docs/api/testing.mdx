---
sidebar_position: 7
title: Testing
description: API reference for testing FORGE applications
---

# Testing

FORGE provides a comprehensive testing framework for unit and integration testing your applications. This includes test contexts for all function types (queries, mutations, actions, jobs, crons, workflows), zero-config database provisioning, HTTP mocking, and assertion macros for common test patterns.

## Quick Start

```rust
use forge::prelude::*;

#[tokio::test]
async fn test_authenticated_query() {
    let user_id = Uuid::new_v4();
    let ctx = TestQueryContext::authenticated(user_id);

    assert_eq!(ctx.require_user_id().unwrap(), user_id);
    assert!(ctx.auth.is_authenticated());
}

#[tokio::test]
async fn test_mutation_dispatches_job() {
    let ctx = TestMutationContext::builder()
        .as_user(Uuid::new_v4())
        .build();

    ctx.dispatch_job("send_welcome_email", serde_json::json!({
        "email": "user@example.com"
    })).await.unwrap();

    assert_job_dispatched!(ctx, "send_welcome_email");
}
```

## Testing Tiers

FORGE supports two testing tiers:

### Unit Tests (No Database)

Fast, isolated tests that don't require a database. Use the `minimal()` or `authenticated()` constructors:

```rust
let ctx = TestQueryContext::minimal();           // No auth
let ctx = TestQueryContext::authenticated(id);   // With user
```

### Integration Tests (With Database)

Tests that require database access. Use `TestDatabase` for zero-config Postgres:

```rust
#[tokio::test]
#[ignore = "requires DATABASE_URL"]
async fn test_with_database() {
    let db = TestDatabase::isolated("my_test").await?;
    db.execute("CREATE TABLE users (id UUID PRIMARY KEY)").await?;

    let ctx = TestQueryContext::with_pool(db.pool().clone(), Some(user_id));
    // Use ctx.db() to access the pool
}
```

## Zero-Config Database

`TestDatabase` provides automatic PostgreSQL setup following sqlx's philosophy of testing against real databases.

### Priority Order

1. **DATABASE_URL environment variable** - For CI with service containers
2. **Embedded PostgreSQL** - Automatic download and start (requires `embedded-test-db` feature)
3. **Error** - If neither is available

### Usage

**Shared Pool (for read-only tests):**

```rust
let pool = TestDatabase::pool().await?;
```

**Isolated Database (for tests that modify data):**

```rust
let db = TestDatabase::isolated("test_name").await?;
db.execute("CREATE TABLE users (id UUID PRIMARY KEY)").await?;

// Use db.pool() for queries
let count: (i64,) = sqlx::query_as("SELECT COUNT(*) FROM users")
    .fetch_one(db.pool())
    .await?;

// Clean up (optional - orphaned databases are cleaned on next run)
db.cleanup().await?;
```

### Running Tests

```bash
# With external database
DATABASE_URL=postgres://localhost/test cargo test

# With embedded Postgres (automatic)
cargo test --features embedded-test-db
```

## Test Contexts

FORGE provides specialized test contexts for each function type.

### TestQueryContext

For testing query functions (read-only database access).

```rust
// Minimal (unauthenticated)
let ctx = TestQueryContext::minimal();

// Authenticated
let ctx = TestQueryContext::authenticated(user_id);

// With roles and claims
let ctx = TestQueryContext::builder()
    .as_user(Uuid::new_v4())
    .with_role("admin")
    .with_claim("org_id", serde_json::json!("org_123"))
    .with_tenant(tenant_id)
    .build();

// With database
let ctx = TestQueryContext::with_pool(pool, Some(user_id));
```

**Methods:**

| Method | Description |
|--------|-------------|
| `auth` | Authentication context |
| `db()` | Optional database pool |
| `require_user_id()` | Returns user ID or error |
| `tenant_id()` | Returns tenant ID if set |

### TestMutationContext

For testing mutations (write operations + job/workflow dispatch).

```rust
let ctx = TestMutationContext::builder()
    .as_user(Uuid::new_v4())
    .build();

// Dispatch a job
ctx.dispatch_job("send_email", serde_json::json!({
    "to": "user@example.com"
})).await?;

// Start a workflow
ctx.start_workflow("onboarding", serde_json::json!({
    "user_id": "123"
})).await?;

// Verify
assert_job_dispatched!(ctx, "send_email");
assert_workflow_started!(ctx, "onboarding");
```

**Methods:**

| Method | Description |
|--------|-------------|
| `job_dispatch()` | Access mock job dispatch for verification |
| `workflow_dispatch()` | Access mock workflow dispatch for verification |
| `dispatch_job(type, args)` | Dispatch a job |
| `start_workflow(name, input)` | Start a workflow |

### TestActionContext

For testing actions (external HTTP calls).

```rust
let ctx = TestActionContext::builder()
    .as_user(Uuid::new_v4())
    .mock_http_json("https://api.stripe.com/*", serde_json::json!({
        "id": "ch_123",
        "status": "succeeded"
    }))
    .build();

// After your action makes HTTP calls:
ctx.http().assert_called("https://api.stripe.com/*");
ctx.http().assert_called_times("https://api.stripe.com/*", 1);
```

**Builder Methods:**

| Method | Description |
|--------|-------------|
| `mock_http(pattern, handler)` | Add HTTP mock with custom handler |
| `mock_http_json(pattern, response)` | Add HTTP mock with JSON response |

### TestJobContext

For testing background jobs.

```rust
let ctx = TestJobContext::builder("export_users")
    .with_job_id(Uuid::new_v4())
    .build();

// Track progress
ctx.progress(50, "Halfway done")?;

// Access progress updates
let updates = ctx.progress_updates();
assert_eq!(updates.len(), 1);
```

**Simulating Retries:**

```rust
// First attempt
let ctx = TestJobContext::builder("my_job").build();
assert!(!ctx.is_retry());

// Retry attempt
let ctx = TestJobContext::builder("my_job")
    .as_retry(3)
    .with_max_attempts(5)
    .build();
assert!(ctx.is_retry());
assert!(!ctx.is_last_attempt());

// Last attempt
let ctx = TestJobContext::builder("my_job")
    .as_last_attempt()
    .build();
assert!(ctx.is_last_attempt());
```

### TestCronContext

For testing scheduled cron functions.

```rust
use chrono::Duration;

let ctx = TestCronContext::builder("daily_cleanup")
    .scheduled_at(Utc::now() - Duration::minutes(5))
    .build();

// Check if running late
assert!(ctx.is_late());
assert!(ctx.delay() > Duration::minutes(4));

// Logging
ctx.log.info("Starting cleanup");
ctx.log.warn("Slow query");
ctx.log.error("Failed");

let entries = ctx.log.entries();
```

**Catch-up Runs:**

```rust
let ctx = TestCronContext::builder("hourly_sync")
    .as_catch_up()
    .build();
assert!(ctx.is_catch_up);
```

### TestWorkflowContext

For testing durable workflows.

```rust
let ctx = TestWorkflowContext::builder("account_verification")
    .with_run_id(Uuid::new_v4())
    .with_version(1)
    .build();

// Track steps
ctx.record_step_start("validate_email");
ctx.record_step_complete("validate_email", serde_json::json!({"valid": true}));

assert!(ctx.is_step_completed("validate_email"));
let result: serde_json::Value = ctx.get_step_result("validate_email")?;
```

**Simulating Resume:**

```rust
let ctx = TestWorkflowContext::builder("verification")
    .as_resumed()
    .with_completed_step("step1", serde_json::json!({}))
    .with_completed_step("step2", serde_json::json!({}))
    .build();

assert!(ctx.is_resumed());
assert!(ctx.is_step_completed("step1"));
```

**Durable Sleep:**

```rust
use std::time::Duration;

let ctx = TestWorkflowContext::builder("delayed").build();
ctx.sleep(Duration::from_secs(3600)).await?;
assert!(ctx.sleep_called());
```

## MockHttp

Mocks external HTTP requests with pattern matching and request verification.

### Creating Mocks

```rust
let ctx = TestActionContext::builder()
    // Static JSON response
    .mock_http_json("https://api.example.com/*", serde_json::json!({
        "status": "ok"
    }))
    // Dynamic response
    .mock_http("https://api.example.com/users/*", |req| {
        let user_id = req.url.split('/').last().unwrap_or("unknown");
        MockResponse::json(serde_json::json!({
            "id": user_id,
            "name": "Test User"
        }))
    })
    .build();
```

### Pattern Matching

Patterns support wildcards:
- `*` matches any characters
- `?` matches a single character

```rust
// Match any Stripe API call
.mock_http("https://api.stripe.com/*", |_| MockResponse::ok())

// Match specific path pattern
.mock_http("https://api.example.com/v?/users/*", |_| MockResponse::ok())
```

### MockResponse Helpers

```rust
// Success with JSON body (200)
MockResponse::json(serde_json::json!({ "id": 123 }))

// Empty success (200)
MockResponse::ok()

// Custom error
MockResponse::error(400, "Invalid request")

// Common error shortcuts
MockResponse::not_found("User not found")
MockResponse::unauthorized("Invalid token")
MockResponse::internal_error("Database error")
```

### Request Verification

```rust
let ctx = TestActionContext::builder()
    .mock_http_json("https://api.example.com/*", serde_json::json!({}))
    .build();

// After making requests...

// Assert a call was made
ctx.http().assert_called("https://api.example.com/*");

// Assert exact call count
ctx.http().assert_called_times("https://api.example.com/*", 2);

// Assert no calls were made
ctx.http().assert_not_called("https://api.other.com/*");

// Get all recorded requests
let requests = ctx.http().requests();
```

### MockRequest

```rust
pub struct MockRequest {
    pub method: String,      // "GET", "POST", etc.
    pub url: String,         // Full URL
    pub headers: HashMap<String, String>,
    pub body: serde_json::Value,
}
```

## Mock Dispatch

### MockJobDispatch

Records dispatched jobs for verification.

```rust
let ctx = TestMutationContext::builder().build();

ctx.dispatch_job("send_email", serde_json::json!({
    "to": "user@example.com"
})).await?;

// Assertions
ctx.job_dispatch().assert_dispatched("send_email");
ctx.job_dispatch().assert_dispatched_with("send_email", |args| {
    args["to"] == "user@example.com"
});
ctx.job_dispatch().assert_not_dispatched("other_job");
ctx.job_dispatch().assert_dispatch_count("send_email", 1);

// Get all dispatched jobs
let jobs = ctx.job_dispatch().dispatched_jobs();
```

### MockWorkflowDispatch

Records started workflows for verification.

```rust
let ctx = TestMutationContext::builder().build();

ctx.start_workflow("onboarding", serde_json::json!({
    "user_id": "123"
})).await?;

// Assertions
ctx.workflow_dispatch().assert_started("onboarding");
ctx.workflow_dispatch().assert_started_with("onboarding", |input| {
    input["user_id"] == "123"
});
ctx.workflow_dispatch().assert_not_started("other_workflow");
```

## Assertion Macros

### `assert_ok!`

Asserts that a Result is Ok.

```rust
let result: Result<User> = create_user(&input).await;
assert_ok!(result);
assert_ok!(result, "user creation should succeed");
```

### `assert_err!`

Asserts that a Result is Err.

```rust
let result = create_user(&invalid_input).await;
assert_err!(result);
assert_err!(result, "should reject invalid email");
```

### `assert_err_variant!`

Asserts that an error matches a specific variant.

```rust
let result = get_user(invalid_id).await;
assert_err_variant!(result, ForgeError::NotFound(_));

let result = admin_action(&regular_user_ctx).await;
assert_err_variant!(result, ForgeError::Forbidden(_));
```

### `assert_job_dispatched!`

Asserts that a job was dispatched.

```rust
assert_job_dispatched!(ctx, "send_email");

// With predicate on input
assert_job_dispatched!(ctx, "send_email", |input| {
    input["to"] == "user@example.com"
});
```

### `assert_job_not_dispatched!`

Asserts that a job was not dispatched.

```rust
assert_job_not_dispatched!(ctx, "dangerous_job");
```

### `assert_workflow_started!`

Asserts that a workflow was started.

```rust
assert_workflow_started!(ctx, "user_onboarding");
```

### `assert_workflow_not_started!`

Asserts that a workflow was not started.

```rust
assert_workflow_not_started!(ctx, "unused_workflow");
```

### `assert_http_called!`

Asserts that an HTTP call was made.

```rust
assert_http_called!(ctx, "https://api.stripe.com/*");
```

### `assert_http_not_called!`

Asserts that an HTTP call was not made.

```rust
assert_http_not_called!(ctx, "https://api.internal.com/*");
```

## Helper Functions

### `error_contains`

Checks if an error message contains a substring.

```rust
let err = ForgeError::Validation("email is required".into());
assert!(error_contains(&err, "email"));
assert!(error_contains(&err, "required"));
```

### `validation_error_for_field`

Checks if a validation error mentions a specific field.

```rust
let err = ForgeError::Validation("email: is invalid".into());
assert!(validation_error_for_field(&err, "email"));
```

### `assert_json_matches`

Performs partial JSON matching. The pattern only needs to contain the fields you want to check.

```rust
let actual = serde_json::json!({
    "id": 123,
    "name": "Test User",
    "email": "test@example.com",
    "created_at": "2024-01-01T00:00:00Z"
});

// Partial match - only check specific fields
assert!(assert_json_matches(&actual, &serde_json::json!({
    "id": 123,
    "name": "Test User"
})));

// Nested objects work too
let nested = serde_json::json!({
    "user": { "id": 1, "name": "Alice" },
    "meta": { "version": "1.0" }
});

assert!(assert_json_matches(&nested, &serde_json::json!({
    "user": { "id": 1 }
})));
```

## Complete Example

```rust
use forge::prelude::*;

#[tokio::test]
async fn test_order_creation_flow() {
    // Setup mutation context with HTTP mock
    let ctx = TestMutationContext::builder()
        .as_user(Uuid::new_v4())
        .with_role("customer")
        .build();

    // Simulate order creation that dispatches jobs
    ctx.dispatch_job("process_payment", serde_json::json!({
        "order_id": "order_123",
        "amount": 4999
    })).await.unwrap();

    ctx.dispatch_job("send_confirmation", serde_json::json!({
        "order_id": "order_123",
        "email": "customer@example.com"
    })).await.unwrap();

    // Start fulfillment workflow
    ctx.start_workflow("order_fulfillment", serde_json::json!({
        "order_id": "order_123"
    })).await.unwrap();

    // Verify jobs were dispatched
    assert_job_dispatched!(ctx, "process_payment");
    assert_job_dispatched!(ctx, "send_confirmation");
    assert_job_not_dispatched!(ctx, "admin_notification");

    // Verify workflow was started
    assert_workflow_started!(ctx, "order_fulfillment");

    // Verify job inputs
    ctx.job_dispatch().assert_dispatched_with("process_payment", |args| {
        args["amount"] == 4999
    });
}

#[tokio::test]
async fn test_action_with_external_api() {
    let ctx = TestActionContext::builder()
        .as_user(Uuid::new_v4())
        .mock_http_json("https://api.stripe.com/v1/charges", serde_json::json!({
            "id": "ch_123",
            "status": "succeeded"
        }))
        .mock_http("https://api.shipping.com/*", |_| {
            MockResponse::json(serde_json::json!({
                "tracking_number": "1Z999AA10123456784"
            }))
        })
        .build();

    // Your action code would make HTTP calls here...

    // Verify the calls were made
    ctx.http().assert_called("https://api.stripe.com/*");
    ctx.http().assert_not_called("https://api.internal.com/*");
}

#[tokio::test]
async fn test_job_with_retries() {
    // Test first attempt
    let ctx = TestJobContext::builder("sync_data").build();
    assert!(!ctx.is_retry());

    // Test retry behavior
    let ctx = TestJobContext::builder("sync_data")
        .as_retry(2)
        .with_max_attempts(3)
        .build();

    assert!(ctx.is_retry());
    assert!(!ctx.is_last_attempt());

    ctx.progress(50, "Retrying...").unwrap();
    assert_eq!(ctx.progress_updates().len(), 1);
}

#[tokio::test]
async fn test_workflow_steps() {
    let ctx = TestWorkflowContext::builder("user_onboarding")
        .build();

    // Record step execution
    ctx.record_step_complete("create_account", serde_json::json!({
        "user_id": "123"
    }));
    ctx.record_step_complete("setup_profile", serde_json::json!({}));
    ctx.record_step_complete("send_welcome", serde_json::json!({}));

    // Verify steps
    assert!(ctx.is_step_completed("create_account"));
    assert!(ctx.is_step_completed("send_welcome"));

    let completed = ctx.completed_step_names();
    assert_eq!(completed, vec!["create_account", "setup_profile", "send_welcome"]);
}
```

## See Also

- [Background Jobs](/background/jobs) - Full jobs guide
- [Workflows](/background/workflows) - Workflows guide
- [ForgeError](/api/forge-error) - Error types
