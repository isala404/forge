---
sidebar_position: 4
title: Real-Time Updates
description: Automatic live data with WebSocket subscriptions
---

# Real-Time Updates

FORGE makes real-time data simple. Subscribe to a query, and it updates automatically when the data changes. No WebSocket setup, no event handlers, no Redux.

## How It Works

```
Your Svelte Component
        â”‚
        â–¼
subscribe('list_tasks', {})
        â”‚
        â–¼
WebSocket connection to FORGE
        â”‚
        â–¼
FORGE watches PostgreSQL changes
        â”‚
        â–¼
When data changes â†’ Query re-runs â†’ UI updates
```

## Basic Subscription

```svelte title="src/routes/+page.svelte"
<script lang="ts">
  import { subscribe } from '$lib/forge';

  // This updates automatically when tasks change!
  const tasks = subscribe('list_tasks', {});
</script>

{#if $tasks.loading}
  <p>Loading tasks...</p>
{:else if $tasks.error}
  <p>Error: {$tasks.error.message}</p>
{:else}
  {#each $tasks.data ?? [] as task}
    <div class="task">
      <input type="checkbox" checked={task.completed} />
      <span>{task.title}</span>
    </div>
  {/each}
{/if}
```

## Enable Reactivity

For real-time to work, you need to enable reactivity on your tables:

```sql title="migrations/0001_initial.sql"
-- Create your table
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    completed BOOLEAN NOT NULL DEFAULT false,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enable real-time updates (THIS IS REQUIRED)
SELECT forge_enable_reactivity('tasks');
```

This creates PostgreSQL triggers that notify FORGE when data changes.

## Subscription Store

The `subscribe` function returns a Svelte store with this shape:

```typescript
interface SubscriptionResult<T> {
  loading: boolean;    // True while initial data loads
  data: T | null;      // The data from your query
  error: Error | null; // Any error that occurred
  stale: boolean;      // True if data might be outdated
}
```

## Query vs Subscribe

| Function | Use When |
|----------|----------|
| `query()` | One-time fetch (page load, search) |
| `subscribe()` | Live updates (lists, dashboards) |

```typescript
// One-time fetch
const user = await query('get_user', { id: userId });

// Live subscription
const tasks = subscribe('list_tasks', {});
```

## Reactive Parameters

Subscribe with dynamic parameters:

```svelte
<script lang="ts">
  import { subscribe } from '$lib/forge';

  let { projectId } = $props();

  // Re-subscribes when projectId changes
  const tasks = subscribe('list_project_tasks', () => ({ projectId }));
</script>
```

## Mutations Trigger Updates

When you run a mutation, subscriptions update automatically:

```svelte
<script lang="ts">
  import { subscribe, mutate } from '$lib/forge';

  const tasks = subscribe('list_tasks', {});

  async function addTask(title: string) {
    // This mutation...
    await mutate('create_task', { title });

    // ...automatically updates $tasks!
    // No refetch needed
  }
</script>

<button onclick={() => addTask('New task')}>
  Add Task
</button>

{#each $tasks.data ?? [] as task}
  <div>{task.title}</div>
{/each}
```

## Connection States

Handle connection issues gracefully:

```svelte
<script lang="ts">
  import { getForgeClient } from '$lib/forge';

  const client = getForgeClient();

  // Listen for connection changes
  client.onConnectionStateChange((state) => {
    console.log('Connection:', state);
    // 'connecting' | 'connected' | 'reconnecting' | 'disconnected'
  });
</script>

{#if client.getConnectionState() === 'reconnecting'}
  <div class="banner">
    Reconnecting...
  </div>
{/if}
```

## Optimistic Updates

For instant UI feedback:

```svelte
<script lang="ts">
  import { subscribe, mutate } from '$lib/forge';

  const tasks = subscribe('list_tasks', {});

  async function toggleTask(task: Task) {
    // Optimistically update the UI
    const oldData = $tasks.data;
    $tasks.data = $tasks.data?.map(t =>
      t.id === task.id ? { ...t, completed: !t.completed } : t
    );

    try {
      await mutate('toggle_task', { id: task.id });
    } catch (error) {
      // Rollback on error
      $tasks.data = oldData;
    }
  }
</script>
```

Or use the built-in helpers:

```typescript
import { mutateOptimisticUpdate } from '$lib/forge';

async function toggleTask(task: Task) {
  await mutateOptimisticUpdate(
    'toggle_task',
    tasks,
    {
      input: { id: task.id },
      itemId: task.id,
      getId: (t) => t.id,
      update: (t) => ({ ...t, completed: !t.completed }),
    }
  );
}
```

## Multiple Subscriptions

Subscribe to multiple queries:

```svelte
<script lang="ts">
  import { subscribe } from '$lib/forge';

  const tasks = subscribe('list_tasks', {});
  const users = subscribe('list_users', {});
  const stats = subscribe('get_dashboard_stats', {});
</script>

<div class="dashboard">
  <TaskList tasks={$tasks.data ?? []} />
  <UserList users={$users.data ?? []} />
  <StatsPanel stats={$stats.data} />
</div>
```

## Under the Hood

FORGE uses PostgreSQL's LISTEN/NOTIFY:

1. When you call `forge_enable_reactivity('tasks')`, FORGE creates a trigger
2. When a row is inserted/updated/deleted, the trigger fires
3. PostgreSQL sends a NOTIFY to FORGE
4. FORGE finds all subscriptions watching that table
5. FORGE re-runs the queries
6. Results are pushed via WebSocket

```sql
-- This is what forge_enable_reactivity creates:
CREATE TRIGGER tasks_notify_changes
    AFTER INSERT OR UPDATE OR DELETE ON tasks
    FOR EACH ROW EXECUTE FUNCTION forge_notify_change();
```

## Architecture Deep Dive

This section explains the internal components that power FORGE's reactivity system.

### The Reactivity Pipeline

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         PostgreSQL Database                              â”‚
â”‚                                                                          â”‚
â”‚  INSERT/UPDATE/DELETE â”€â”€â–º Trigger â”€â”€â–º NOTIFY 'forge_changes'            â”‚
â”‚                          (forge_notify_change)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ChangeListener                                 â”‚
â”‚                                                                        â”‚
â”‚  â€¢ PostgreSQL PgListener on 'forge_changes' channel                   â”‚
â”‚  â€¢ Parses notification payload: "table:operation:row_id:columns"      â”‚
â”‚  â€¢ Converts to Change struct and broadcasts to Reactor                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      InvalidationEngine                                â”‚
â”‚                                                                        â”‚
â”‚  â€¢ Receives Change events                                              â”‚
â”‚  â€¢ Finds affected subscriptions via SubscriptionManager               â”‚
â”‚  â€¢ Debounces rapid changes (50ms window, 200ms max wait)              â”‚
â”‚  â€¢ Coalesces multiple changes to same table                           â”‚
â”‚  â€¢ Returns list of SubscriptionIds to invalidate                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            Reactor                                     â”‚
â”‚                                                                        â”‚
â”‚  â€¢ Main orchestrator connecting all components                        â”‚
â”‚  â€¢ Re-executes queries for invalidated subscriptions                  â”‚
â”‚  â€¢ Compares result hash to detect actual data changes                 â”‚
â”‚  â€¢ Pushes updates only when data differs                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        WebSocketServer                                 â”‚
â”‚                                                                        â”‚
â”‚  â€¢ Manages client connections and subscriptions                       â”‚
â”‚  â€¢ Routes data updates to correct sessions                           â”‚
â”‚  â€¢ Handles subscribe/unsubscribe messages                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
                          Your Svelte Component
```

### Core Types

#### ReadSet

Tracks which tables (and optionally rows) a query accesses. Used to determine if a change should invalidate a subscription.

```rust
pub struct ReadSet {
    /// Tables accessed by the query
    pub tables: HashSet<String>,
    /// Specific rows read per table (for row-level tracking)
    pub rows: HashMap<String, HashSet<Uuid>>,
    /// Tracking granularity
    pub mode: TrackingMode,
}
```

#### TrackingMode

Controls invalidation granularity:

| Mode | Description | Status |
|------|-------------|--------|
| `Table` | Invalidate when any row in the table changes | Fully implemented |
| `Row` | Invalidate only when specific read rows change | Defined, not active |
| `Adaptive` | Auto-select based on query characteristics | Planned |

Currently, FORGE uses table-level tracking. This means if your query reads from the `tasks` table, any INSERT/UPDATE/DELETE on `tasks` will trigger a re-query.

#### Delta&lt;T&gt;

Represents incremental changes for subscription updates:

```rust
pub struct Delta<T> {
    /// New items added
    pub added: Vec<T>,
    /// IDs of removed items
    pub removed: Vec<String>,
    /// Updated items
    pub updated: Vec<T>,
}
```

While the `Delta<T>` struct exists, FORGE currently sends full query results rather than incremental deltas. This may change in future versions.

### Component Details

#### ChangeListener

Listens for PostgreSQL NOTIFY events on the `forge_changes` channel.

```rust
pub struct ChangeListener {
    pool: sqlx::PgPool,
    config: ListenerConfig,  // channel name, buffer size
    change_tx: broadcast::Sender<Change>,
}
```

**Notification format:** `table:operation:row_id:columns`

Examples:
- `tasks:INSERT:550e8400-e29b-41d4-a716-446655440000`
- `tasks:UPDATE:550e8400-e29b-41d4-a716-446655440000:title,completed`
- `tasks:DELETE:550e8400-e29b-41d4-a716-446655440000`

#### InvalidationEngine

Determines which subscriptions need re-execution when data changes.

```rust
pub struct InvalidationConfig {
    /// Debounce window (default: 50ms)
    pub debounce_ms: u64,
    /// Max wait before forcing flush (default: 200ms)
    pub max_debounce_ms: u64,
    /// Group changes by table (default: true)
    pub coalesce_by_table: bool,
    /// Force flush threshold (default: 1000)
    pub max_buffer_size: usize,
}
```

The debounce logic prevents overwhelming the system during bulk operations:
- Multiple rapid changes to the same table are coalesced
- Subscriptions are invalidated after the debounce window closes
- Maximum wait prevents starvation during continuous writes

#### Reactor

The central coordinator that wires everything together:

```rust
pub struct Reactor {
    db_pool: sqlx::PgPool,
    registry: FunctionRegistry,
    subscription_manager: Arc<SubscriptionManager>,
    ws_server: Arc<WebSocketServer>,
    change_listener: Arc<ChangeListener>,
    invalidation_engine: Arc<InvalidationEngine>,
    active_subscriptions: Arc<RwLock<HashMap<SubscriptionId, ActiveSubscription>>>,
}
```

**Key responsibilities:**
1. Register/unregister WebSocket sessions
2. Handle subscribe/unsubscribe requests
3. Execute queries and track their read sets
4. Process changes and push updates

**Read set extraction:** The Reactor infers which tables a query touches from the query name:
- `get_users` â†’ tracks `users` table
- `list_tasks` â†’ tracks `tasks` table
- `find_projects` â†’ tracks `projects` table
- `fetch_orders` â†’ tracks `orders` table

### Enabling and Disabling Reactivity

#### forge_enable_reactivity(table_name)

Creates a trigger on the specified table that fires NOTIFY on changes:

```sql
SELECT forge_enable_reactivity('tasks');
-- Creates: tasks_forge_notify trigger
```

What it does internally:
1. Creates a trigger named `{table}_forge_notify`
2. Trigger fires AFTER INSERT, UPDATE, or DELETE
3. Calls `forge_notify_change()` function
4. Function sends NOTIFY with change details

#### forge_disable_reactivity(table_name)

Removes the trigger to stop change notifications:

```sql
SELECT forge_disable_reactivity('tasks');
-- Drops: tasks_forge_notify trigger
```

#### forge_notify_change()

The trigger function that constructs and sends notifications:

```sql
CREATE OR REPLACE FUNCTION forge_notify_change()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_notify('forge_changes',
        TG_TABLE_NAME || ':' || TG_OP || ':' ||
        COALESCE(NEW.id::text, OLD.id::text, '')
    );
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;
```

### Subscription Lifecycle

1. **Client subscribes:** WebSocket message `{ type: "subscribe", query: "list_tasks", args: {} }`
2. **Reactor processes:** Creates `SubscriptionInfo`, executes query, stores read set
3. **Initial data sent:** `{ type: "data", subscriptionId: "...", data: [...] }`
4. **Change occurs:** INSERT/UPDATE/DELETE on tasks table
5. **Trigger fires:** NOTIFY sent to `forge_changes` channel
6. **ChangeListener receives:** Parses notification, broadcasts Change
7. **InvalidationEngine processes:** Finds subscriptions watching `tasks` table
8. **Reactor re-executes:** Runs query again, compares result hash
9. **Update pushed (if changed):** `{ type: "data", subscriptionId: "...", data: [...] }`

### Implementation Notes

**Current limitations:**
- Table-level tracking only (row-level tracking is defined but not active)
- Full result replacement (no delta updates yet)
- Read set inference from query names (explicit tracking attributes planned)
- Debounce timings are hardcoded (configuration planned)

**What is implemented:**
- Full ChangeListener â†’ InvalidationEngine â†’ Reactor â†’ WebSocket pipeline
- Debounce and coalesce logic for high-frequency changes
- Result hash comparison to avoid redundant updates
- Job and workflow subscriptions (bonus feature beyond queries)

## Performance Tips

### 1. Subscribe to Specific Data

```typescript
// Good: Subscribe to user's tasks only
const tasks = subscribe('get_user_tasks', { userId });

// Less efficient: Subscribe to all tasks, filter client-side
const allTasks = subscribe('list_all_tasks', {});
```

### 2. Use Query for One-Time Data

```typescript
// Good: One-time fetch for user profile
const user = await query('get_user', { id });

// Wasteful: Subscribing to rarely-changing data
const user = subscribe('get_user', { id });
```

### 3. Unsubscribe When Done

Subscriptions are cleaned up automatically when components unmount, but you can also manually unsubscribe:

```typescript
const tasks = subscribe('list_tasks', {});

// Later
tasks.unsubscribe();
```

## Debugging

Enable debug logging:

```typescript
import { setForgeDebug } from '$lib/forge';

setForgeDebug(true);
// Logs: [FORGE] Subscribe: list_tasks
// Logs: [FORGE] Data update: list_tasks
```

## What's Next?

<div className="row">
  <div className="col col--6">
    <a className="card" href="/frontend/realtime-subscriptions">
      <div className="card__header">
        <h3>ğŸ“¡ Frontend Subscriptions</h3>
      </div>
      <div className="card__body">
        Advanced subscription patterns
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a className="card" href="/frontend/job-tracking">
      <div className="card__header">
        <h3>ğŸ“Š Job Tracking</h3>
      </div>
      <div className="card__body">
        Real-time job progress
      </div>
    </a>
  </div>
</div>
