---
sidebar_position: 2
title: Schema & Data Models
description: Define your data models in Rust and let FORGE do the rest
---

# Schema & Data Models

In FORGE, you define your data models as Rust structs using the `#[forge::model]` proc macro. These become:
- Database tables with proper indexes and constraints
- TypeScript types for the frontend
- API request/response types

Write once, use everywhere.

## Basic Model

```rust title="src/schema/mod.rs"
use forge::prelude::*;

#[forge::model]
pub struct User {
    #[id]
    pub id: Uuid,

    #[indexed]
    #[unique]
    pub email: String,

    pub name: String,

    pub created_at: DateTime<Utc>,

    #[updated_at]
    pub updated_at: DateTime<Utc>,
}
```

The `#[forge::model]` macro automatically:
- Derives `Debug`, `Clone`, `Serialize`, `Deserialize`
- Generates `ModelMeta` trait implementation for schema introspection
- Creates table definition with proper SQL types
- Generates TypeScript types for the frontend

## Field Attributes

FORGE provides several field attributes to control database behavior:

### `#[id]` - Primary Key

Marks a field as the primary key. For `Uuid` fields, automatically adds `DEFAULT gen_random_uuid()`.

```rust
#[forge::model]
pub struct Task {
    #[id]
    pub id: Uuid,  // PRIMARY KEY DEFAULT gen_random_uuid()
    // ...
}
```

### `#[indexed]` - Database Index

Creates a B-tree index on the field for faster lookups.

```rust
#[forge::model]
pub struct Task {
    #[id]
    pub id: Uuid,

    #[indexed]
    pub user_id: Uuid,  // Creates idx_tasks_user_id

    #[indexed]
    pub status: TaskStatus,
    // ...
}
```

### `#[unique]` - Unique Constraint

Adds a UNIQUE constraint to prevent duplicate values.

```rust
#[forge::model]
pub struct User {
    #[id]
    pub id: Uuid,

    #[unique]
    pub email: String,  // UNIQUE NOT NULL

    #[unique]
    pub username: String,
    // ...
}
```

### `#[encrypted]` - Encrypted Field

Marks a field for encryption at rest. The value is encrypted before storage and decrypted on retrieval.

```rust
#[forge::model]
pub struct UserSecret {
    #[id]
    pub id: Uuid,

    pub user_id: Uuid,

    #[encrypted]
    pub api_key: String,  // Encrypted in database

    #[encrypted]
    pub refresh_token: Option<String>,
}
```

### `#[updated_at]` - Auto-Update Timestamp

Marks a timestamp field to be automatically updated on every modification.

```rust
#[forge::model]
pub struct Document {
    #[id]
    pub id: Uuid,

    pub content: String,

    pub created_at: DateTime<Utc>,

    #[updated_at]
    pub updated_at: DateTime<Utc>,  // Auto-updates on every save
}
```

### `#[soft_delete]` - Soft Delete Support

Enable soft delete for a model. Instead of permanently deleting rows, they're marked with a `deleted_at` timestamp.

```rust
#[forge::model]
#[soft_delete]
pub struct Document {
    #[id]
    pub id: Uuid,

    pub title: String,

    pub content: String,

    pub created_at: DateTime<Utc>,

    // deleted_at is automatically added by #[soft_delete]
}
```

The `#[soft_delete]` attribute automatically:
- Adds a `deleted_at: Option<DateTime<Utc>>` column
- Creates a partial index for efficient queries on non-deleted rows
- Sets up `WHERE deleted_at IS NULL` as the default query pattern

**Migration with soft delete:**

```sql title="migrations/0002_documents.sql"
-- @up
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMPTZ  -- Added by #[soft_delete]
);

-- Partial index for efficient queries on active documents
CREATE INDEX idx_documents_active ON documents(created_at DESC) WHERE deleted_at IS NULL;

SELECT forge_enable_reactivity('documents');

-- @down
DROP TABLE documents;
```

**Querying soft-deleted records:**

```rust
// Get active documents only
#[forge::query]
pub async fn list_documents(ctx: &QueryContext) -> Result<Vec<Document>> {
    sqlx::query_as("SELECT * FROM documents WHERE deleted_at IS NULL ORDER BY created_at DESC")
        .fetch_all(ctx.db())
        .await
        .map_err(Into::into)
}

// Include deleted documents
#[forge::query]
pub async fn list_all_documents(ctx: &QueryContext) -> Result<Vec<Document>> {
    sqlx::query_as("SELECT * FROM documents ORDER BY created_at DESC")
        .fetch_all(ctx.db())
        .await
        .map_err(Into::into)
}

// Soft delete
#[forge::mutation]
pub async fn delete_document(ctx: &MutationContext, id: Uuid) -> Result<bool> {
    let result = sqlx::query("UPDATE documents SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL")
        .bind(id)
        .execute(ctx.db())
        .await?;
    Ok(result.rows_affected() > 0)
}

// Restore a soft-deleted document
#[forge::mutation]
pub async fn restore_document(ctx: &MutationContext, id: Uuid) -> Result<bool> {
    let result = sqlx::query("UPDATE documents SET deleted_at = NULL WHERE id = $1")
        .bind(id)
        .execute(ctx.db())
        .await?;
    Ok(result.rows_affected() > 0)
}
```

### `#[default = "..."]` - Default Value

Sets a SQL default value expression for the field.

```rust
#[forge::model]
pub struct Task {
    #[id]
    pub id: Uuid,

    pub title: String,

    #[default = "'pending'"]
    pub status: String,

    #[default = "0"]
    pub retry_count: i32,

    #[default = "NOW()"]
    pub created_at: DateTime<Utc>,
}
```

## Table Name Configuration

By default, the table name is derived from the struct name (pluralized and snake_cased).
Use `#[table(name = "...")]` to customize:

```rust
#[forge::model]
#[table(name = "user_accounts")]
pub struct User {
    #[id]
    pub id: Uuid,
    pub email: String,
}
// Table name: user_accounts (not "users")
```

## Composite Indexes

For indexes spanning multiple columns, define them at the table level:

```rust
#[forge::model]
pub struct Task {
    #[id]
    pub id: Uuid,

    #[indexed]
    pub user_id: Uuid,

    pub status: TaskStatus,

    pub priority: i32,

    pub created_at: DateTime<Utc>,
}
```

In your migration, add composite indexes:

```sql title="migrations/0001_tasks.sql"
-- @up
CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    status task_status NOT NULL DEFAULT 'pending',
    priority INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Composite index for querying user tasks by status
CREATE INDEX idx_tasks_user_status ON tasks(user_id, status);

-- Composite index for priority queue
CREATE INDEX idx_tasks_status_priority ON tasks(status, priority DESC);

SELECT forge_enable_reactivity('tasks');

-- @down
DROP TABLE tasks;
```

## Migration for Your Model

Create a migration to set up the database table:

```sql title="migrations/0001_initial.sql"
-- @up
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Enable real-time updates for this table
SELECT forge_enable_reactivity('users');

-- @down
DROP TABLE users;
```

:::tip Up and Down Migrations
The `-- @up` marker starts the "up" migration (apply changes).
The `-- @down` marker starts the "down" migration (rollback).
:::

## Type Mappings

| Rust Type | PostgreSQL Type | TypeScript Type |
|-----------|-----------------|-----------------|
| `String` | `VARCHAR(255)` | `string` |
| `i32` | `INTEGER` | `number` |
| `i64` | `BIGINT` | `number` |
| `f32` | `REAL` | `number` |
| `f64` | `DOUBLE PRECISION` | `number` |
| `bool` | `BOOLEAN` | `boolean` |
| `Uuid` | `UUID` | `string` |
| `DateTime<Utc>` | `TIMESTAMPTZ` | `Date` |
| `NaiveDate` | `DATE` | `Date` |
| `Option<T>` | Nullable | `T \| null` |
| `Vec<T>` | `T[]` | `T[]` |
| `Vec<u8>` | `BYTEA` | `Uint8Array` |
| `serde_json::Value` | `JSONB` | `unknown` |
| Custom enum | Custom ENUM | Union type |

## Enums

Use `#[forge::forge_enum]` to define type-safe enum fields that map to PostgreSQL ENUM types:

```rust title="src/schema/mod.rs"
#[forge::forge_enum]
pub enum TaskStatus {
    Pending,
    InProgress,
    Completed,
    Cancelled,
}
```

The `#[forge::forge_enum]` macro automatically:
- Derives `Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash`, `Serialize`, `Deserialize`
- Implements `Display` and `FromStr` for string conversion
- Implements sqlx `Encode`, `Decode`, and `Type` traits for database operations
- Converts variants to snake_case for SQL (e.g., `InProgress` -> `in_progress`)

Use the enum in your models:

```rust
#[forge::model]
pub struct Task {
    #[id]
    pub id: Uuid,

    pub title: String,

    pub status: TaskStatus,  // Uses the PostgreSQL task_status ENUM

    pub user_id: Uuid,

    pub created_at: DateTime<Utc>,
}
```

Migration:

```sql title="migrations/0002_add_tasks.sql"
-- @up
CREATE TYPE task_status AS ENUM ('pending', 'in_progress', 'completed', 'cancelled');

CREATE TABLE tasks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    status task_status NOT NULL DEFAULT 'pending',
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

SELECT forge_enable_reactivity('tasks');

-- @down
DROP TABLE tasks;
DROP TYPE task_status;
```

### Enum Methods

The generated enum has these methods:

```rust
// Get SQL string representation
let status = TaskStatus::InProgress;
assert_eq!(status.as_sql_str(), "in_progress");

// Get PostgreSQL type name
assert_eq!(TaskStatus::sql_type_name(), "task_status");

// Parse from string
let status: TaskStatus = "completed".parse().unwrap();
assert_eq!(status, TaskStatus::Completed);

// Display
println!("{}", TaskStatus::Pending);  // Prints: pending
```

## Relationships

Model relationships through foreign keys:

```rust title="src/schema/mod.rs"
#[forge::model]
pub struct Task {
    #[id]
    pub id: Uuid,

    pub title: String,

    pub status: TaskStatus,

    #[indexed]
    pub user_id: Uuid,  // Foreign key to users

    pub created_at: DateTime<Utc>,
}

// For queries that need user data, create a joined struct
// This doesn't need #[forge::model] since it's a query result, not a table
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct TaskWithUser {
    pub id: Uuid,
    pub title: String,
    pub status: TaskStatus,
    pub user_id: Uuid,
    pub user_name: String,
    pub user_email: String,
    pub created_at: DateTime<Utc>,
}
```

Query with joins:

```rust title="src/functions/queries/tasks.rs"
#[forge::query]
pub async fn list_tasks_with_users(ctx: &QueryContext) -> Result<Vec<TaskWithUser>> {
    sqlx::query_as(r#"
        SELECT
            t.id, t.title, t.status, t.user_id, t.created_at,
            u.name as user_name, u.email as user_email
        FROM tasks t
        JOIN users u ON u.id = t.user_id
        ORDER BY t.created_at DESC
    "#)
    .fetch_all(ctx.db())
    .await
    .map_err(Into::into)
}
```

## Input Types

Create separate structs for input validation:

```rust title="src/schema/mod.rs"
#[derive(Debug, Clone, Deserialize)]
pub struct CreateUserInput {
    pub email: String,
    pub name: String,
}

#[derive(Debug, Clone, Deserialize)]
pub struct UpdateUserInput {
    pub name: Option<String>,
    pub email: Option<String>,
}
```

Use in mutations:

```rust title="src/functions/mutations/users.rs"
#[forge::mutation]
pub async fn create_user(ctx: &MutationContext, input: CreateUserInput) -> Result<User> {
    // input is automatically deserialized and validated
    sqlx::query_as(r#"
        INSERT INTO users (id, email, name, created_at, updated_at)
        VALUES ($1, $2, $3, NOW(), NOW())
        RETURNING *
    "#)
    .bind(Uuid::new_v4())
    .bind(&input.email)
    .bind(&input.name)
    .fetch_one(ctx.db())
    .await
    .map_err(Into::into)
}
```

## Optional Fields

Use `Option<T>` for nullable fields:

```rust
#[forge::model]
pub struct User {
    #[id]
    pub id: Uuid,

    #[unique]
    pub email: String,

    pub name: String,

    pub avatar_url: Option<String>,  // Nullable

    pub bio: Option<String>,         // Nullable
}
```

## JSONB Fields

Store flexible data with JSONB:

```rust
use serde_json::Value;

#[forge::model]
pub struct UserSettings {
    #[id]
    pub user_id: Uuid,

    pub preferences: Value,  // Stored as JSONB
}
```

Or with typed JSON:

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Preferences {
    pub theme: String,
    pub notifications_enabled: bool,
    pub language: String,
}

#[forge::model]
pub struct UserSettings {
    #[id]
    pub user_id: Uuid,

    #[sqlx(json)]
    pub preferences: Preferences,  // Stored as JSONB, typed in Rust
}
```

## Timestamps

FORGE uses `chrono` for timestamps:

```rust
use chrono::{DateTime, Utc};

#[forge::model]
pub struct Article {
    #[id]
    pub id: Uuid,

    pub title: String,

    #[default = "NOW()"]
    pub created_at: DateTime<Utc>,

    #[updated_at]
    pub updated_at: DateTime<Utc>,  // Auto-updates on every save

    pub published_at: Option<DateTime<Utc>>,  // Nullable timestamp
}
```

:::tip Auto-Update Timestamps
Use the `#[updated_at]` attribute to mark a field for automatic updates.
The field will be set to `NOW()` on every INSERT and UPDATE.
:::

## Project Structure

Organize your schema like this:

```
src/
‚îî‚îÄ‚îÄ schema/
    ‚îú‚îÄ‚îÄ mod.rs        # Re-exports everything
    ‚îú‚îÄ‚îÄ user.rs       # User model
    ‚îú‚îÄ‚îÄ task.rs       # Task model
    ‚îî‚îÄ‚îÄ inputs.rs     # Input types
```

```rust title="src/schema/mod.rs"
mod user;
mod task;
mod inputs;

pub use user::*;
pub use task::*;
pub use inputs::*;
```

## Best Practices

### 1. Keep Models Simple

```rust
// Good: Simple, focused model
#[forge::model]
pub struct User {
    #[id]
    pub id: Uuid,
    #[unique]
    pub email: String,
    pub name: String,
}

// Avoid: Too many fields, do everything model
// Split into multiple related tables instead
```

### 2. Use Specific Types

```rust
// Good: UUID for IDs, enums for status
#[id]
pub id: Uuid,
pub status: TaskStatus,

// Avoid: String for IDs and magic strings
pub id: String,
pub status: String,
```

### 3. Separate Input from Output

```rust
// Input type (what the client sends) - no #[forge::model] needed
#[derive(Debug, Clone, Deserialize)]
pub struct CreateTaskInput {
    pub title: String,
    pub user_id: Uuid,
}

// Output type (what the database returns)
#[forge::model]
pub struct Task {
    #[id]
    pub id: Uuid,
    pub title: String,
    #[indexed]
    pub user_id: Uuid,
    pub created_at: DateTime<Utc>,
}
```

### 4. Use Appropriate Attributes

```rust
#[forge::model]
pub struct User {
    #[id]                    // Primary key
    pub id: Uuid,

    #[unique]                // Prevent duplicates
    pub email: String,

    #[indexed]               // Speed up lookups
    pub created_at: DateTime<Utc>,

    #[updated_at]            // Auto-update on changes
    pub updated_at: DateTime<Utc>,

    #[encrypted]             // Sensitive data
    pub phone_number: Option<String>,
}
```

## What's Next?

<div className="row">
  <div className="col col--6">
    <a className="card" href="/concepts/functions">
      <div className="card__header">
        <h3>‚öôÔ∏è Functions</h3>
      </div>
      <div className="card__body">
        Use your models in queries and mutations
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a className="card" href="/cli/migrate">
      <div className="card__header">
        <h3>üóÉÔ∏è Migrations</h3>
      </div>
      <div className="card__body">
        Learn migration commands
      </div>
    </a>
  </div>
</div>
