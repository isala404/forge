---
sidebar_position: 3
title: Functions
description: Queries, Mutations, and Actions - the building blocks of your API
---

# Functions

Functions are the building blocks of your FORGE API. There are three types, each with a specific purpose:

| Type | Purpose | Can Read DB | Can Write DB | Can Call APIs |
|------|---------|-------------|--------------|---------------|
| **Query** | Fetch data | âœ… | âŒ | âŒ |
| **Mutation** | Modify data | âœ… | âœ… | âŒ |
| **Action** | External calls | âœ… | âœ… | âœ… |

## Queries

Queries are for **reading data**. They're cacheable, subscribable, and can't modify the database.

```rust title="src/functions/queries/users.rs"
use forge::prelude::*;
use crate::schema::User;

#[forge::query]
pub async fn list_users(ctx: &QueryContext) -> Result<Vec<User>> {
    sqlx::query_as("SELECT * FROM users ORDER BY created_at DESC")
        .fetch_all(ctx.db())
        .await
        .map_err(Into::into)
}
```

### With Parameters

```rust
#[forge::query]
pub async fn get_user(ctx: &QueryContext, id: Uuid) -> Result<Option<User>> {
    sqlx::query_as("SELECT * FROM users WHERE id = $1")
        .bind(id)
        .fetch_optional(ctx.db())
        .await
        .map_err(Into::into)
}
```

### With Complex Parameters

```rust
#[derive(Debug, Deserialize)]
pub struct ListUsersParams {
    pub limit: Option<i64>,
    pub offset: Option<i64>,
    pub search: Option<String>,
}

#[forge::query]
pub async fn search_users(ctx: &QueryContext, params: ListUsersParams) -> Result<Vec<User>> {
    let limit = params.limit.unwrap_or(10);
    let offset = params.offset.unwrap_or(0);

    if let Some(search) = &params.search {
        sqlx::query_as(r#"
            SELECT * FROM users
            WHERE name ILIKE $1 OR email ILIKE $1
            ORDER BY created_at DESC
            LIMIT $2 OFFSET $3
        "#)
        .bind(format!("%{}%", search))
        .bind(limit)
        .bind(offset)
        .fetch_all(ctx.db())
        .await
        .map_err(Into::into)
    } else {
        sqlx::query_as("SELECT * FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2")
            .bind(limit)
            .bind(offset)
            .fetch_all(ctx.db())
            .await
            .map_err(Into::into)
    }
}
```

### Query Caching

Enable in-memory caching for expensive queries with the `cache` attribute:

```rust
// Cache results for 30 seconds
#[forge::query(cache = "30s")]
pub async fn get_app_stats(ctx: &QueryContext) -> Result<AppStats> {
    sqlx::query_as(r#"
        SELECT
            COUNT(*) as total_users,
            COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as new_today
        FROM users
    "#)
    .fetch_one(ctx.db())
    .await
    .map_err(Into::into)
}

// Cache for 5 minutes
#[forge::query(cache = "5m")]
pub async fn get_popular_posts(ctx: &QueryContext) -> Result<Vec<Post>> {
    // Expensive aggregation query
}

// Cache for 1 hour
#[forge::query(cache = "1h")]
pub async fn get_categories(ctx: &QueryContext) -> Result<Vec<Category>> {
    // Rarely changing data
}
```

**Cache behavior:**
- Cache key is based on function name + arguments
- Cache is per-node (not distributed)
- TTL starts from first access
- Automatic eviction when cache is full (LRU)

**Supported durations:**
- `Ns` - seconds (e.g., `"30s"`)
- `Nm` - minutes (e.g., `"5m"`)
- `Nh` - hours (e.g., `"1h"`)
- `Nd` - days (e.g., `"1d"`)

:::tip When to Cache
Use caching for:
- Aggregate/analytics queries
- Reference data that rarely changes
- Expensive computations
- High-frequency read endpoints

Don't cache:
- User-specific data (use `public` + rate limiting instead)
- Data that must be real-time
- Queries with high cardinality arguments
:::

## Mutations

Mutations are for **modifying data**. They can read and write to the database, and dispatch background jobs.

```rust title="src/functions/mutations/users.rs"
use forge::prelude::*;
use crate::schema::{User, CreateUserInput};

#[forge::mutation]
pub async fn create_user(ctx: &MutationContext, input: CreateUserInput) -> Result<User> {
    let user = sqlx::query_as(r#"
        INSERT INTO users (id, email, name, created_at, updated_at)
        VALUES ($1, $2, $3, NOW(), NOW())
        RETURNING *
    "#)
    .bind(Uuid::new_v4())
    .bind(&input.email)
    .bind(&input.name)
    .fetch_one(ctx.db())
    .await?;

    Ok(user)
}
```

### With Job Dispatch

```rust
#[forge::mutation]
pub async fn create_user(ctx: &MutationContext, input: CreateUserInput) -> Result<User> {
    let user = sqlx::query_as(r#"
        INSERT INTO users (id, email, name, created_at, updated_at)
        VALUES ($1, $2, $3, NOW(), NOW())
        RETURNING *
    "#)
    .bind(Uuid::new_v4())
    .bind(&input.email)
    .bind(&input.name)
    .fetch_one(ctx.db())
    .await?;

    // Dispatch a background job to send welcome email
    ctx.dispatch_job("send_welcome_email", serde_json::json!({
        "user_id": user.id,
        "email": &user.email,
    })).await?;

    Ok(user)
}
```

### Update and Delete

```rust
#[derive(Debug, Deserialize)]
pub struct UpdateUserInput {
    pub name: Option<String>,
    pub email: Option<String>,
}

#[forge::mutation]
pub async fn update_user(
    ctx: &MutationContext,
    id: Uuid,
    input: UpdateUserInput,
) -> Result<User> {
    let user = sqlx::query_as(r#"
        UPDATE users
        SET name = COALESCE($2, name),
            email = COALESCE($3, email),
            updated_at = NOW()
        WHERE id = $1
        RETURNING *
    "#)
    .bind(id)
    .bind(&input.name)
    .bind(&input.email)
    .fetch_one(ctx.db())
    .await?;

    Ok(user)
}

#[forge::mutation]
pub async fn delete_user(ctx: &MutationContext, id: Uuid) -> Result<bool> {
    let result = sqlx::query("DELETE FROM users WHERE id = $1")
        .bind(id)
        .execute(ctx.db())
        .await?;

    Ok(result.rows_affected() > 0)
}
```

## Actions

Actions are for **external API calls**. They have access to an HTTP client and can call third-party services.

```rust title="src/functions/actions/stripe.rs"
use forge::prelude::*;

#[derive(Debug, Serialize)]
pub struct PaymentResult {
    pub payment_id: String,
    pub status: String,
}

#[forge::action]
pub async fn create_payment(
    ctx: &ActionContext,
    amount: i64,
    currency: String,
) -> Result<PaymentResult> {
    let response = ctx.http()
        .post("https://api.stripe.com/v1/payment_intents")
        .header("Authorization", format!("Bearer {}", std::env::var("STRIPE_KEY")?))
        .form(&[
            ("amount", amount.to_string()),
            ("currency", currency),
        ])
        .send()
        .await?;

    if !response.status().is_success() {
        return Err(ForgeError::External(format!(
            "Stripe API error: {}",
            response.status()
        )));
    }

    let data: serde_json::Value = response.json().await?;

    Ok(PaymentResult {
        payment_id: data["id"].as_str().unwrap_or("").to_string(),
        status: data["status"].as_str().unwrap_or("unknown").to_string(),
    })
}
```

## Context Objects

Each function type gets a different context:

### QueryContext

```rust
pub struct QueryContext {
    pub auth: AuthContext,     // Current user info
    pub request: RequestMetadata, // Request ID, trace ID
}

impl QueryContext {
    fn db(&self) -> &PgPool;   // Database access (read-only)
}
```

### MutationContext

```rust
pub struct MutationContext {
    pub auth: AuthContext,
    pub request: RequestMetadata,
}

impl MutationContext {
    fn db(&self) -> &PgPool;   // Database access (read-write)
    async fn dispatch_job(&self, name: &str, args: Value) -> Result<Uuid>;
    async fn start_workflow(&self, name: &str, input: Value) -> Result<Uuid>;
}
```

### ActionContext

```rust
pub struct ActionContext {
    pub auth: AuthContext,
    pub request: RequestMetadata,
}

impl ActionContext {
    fn db(&self) -> &PgPool;   // Database access
    fn http(&self) -> &Client; // HTTP client
    async fn dispatch_job(&self, name: &str, args: Value) -> Result<Uuid>;
    async fn start_workflow(&self, name: &str, input: Value) -> Result<Uuid>;
}
```

## Authentication

Access the current user through `ctx.auth`:

```rust
#[forge::query]
pub async fn get_my_profile(ctx: &QueryContext) -> Result<User> {
    // Get the authenticated user's ID
    let user_id = ctx.auth.require_user_id()?;

    sqlx::query_as("SELECT * FROM users WHERE id = $1")
        .bind(user_id)
        .fetch_one(ctx.db())
        .await
        .map_err(Into::into)
}

#[forge::mutation]
pub async fn update_my_profile(
    ctx: &MutationContext,
    input: UpdateProfileInput,
) -> Result<User> {
    let user_id = ctx.auth.require_user_id()?;

    // Can also check roles
    if ctx.auth.has_role("admin") {
        // Admin-only logic
    }

    // ...
}
```

## Error Handling

Return errors with `ForgeError`:

```rust
use forge::prelude::*;

#[forge::mutation]
pub async fn create_task(ctx: &MutationContext, input: CreateTaskInput) -> Result<Task> {
    // Validation error
    if input.title.is_empty() {
        return Err(ForgeError::Validation("Title cannot be empty".into()));
    }

    // Check authorization
    let user_id = ctx.auth.require_user_id()?;

    // Database constraint error
    let task = sqlx::query_as(/* ... */)
        .fetch_one(ctx.db())
        .await
        .map_err(|e| match e {
            sqlx::Error::Database(db_err) if db_err.is_unique_violation() => {
                ForgeError::Validation("Task with this title already exists".into())
            }
            _ => e.into(),
        })?;

    Ok(task)
}
```

## Registering Functions

Functions must be registered in `main.rs`:

```rust title="src/main.rs"
use forge::prelude::*;

mod schema;
mod functions;

use functions::queries::*;
use functions::mutations::*;

#[tokio::main]
async fn main() -> Result<()> {
    let config = ForgeConfig::from_env()?;

    Forge::builder()
        // Register queries
        .function_registry_mut()
        .register_query::<ListUsersQuery>()
        .register_query::<GetUserQuery>()
        // Register mutations
        .register_mutation::<CreateUserMutation>()
        .register_mutation::<UpdateUserMutation>()
        .register_mutation::<DeleteUserMutation>()
        // Build and run
        .config(config)
        .build()?
        .run()
        .await
}
```

:::tip Naming Convention
The macro generates a struct with a suffix:
- `list_users` â†’ `ListUsersQuery`
- `create_user` â†’ `CreateUserMutation`
- `send_email` â†’ `SendEmailAction`
:::

## Calling from Frontend

Functions are called via the `/rpc/{function_name}` endpoint:

```typescript
// Query (one-time fetch)
const users = await query('list_users', {});

// Query with params
const user = await query('get_user', { id: 'uuid' });

// Mutation
const newUser = await mutate('create_user', {
    email: 'user@example.com',
    name: 'John Doe',
});

// Action
const payment = await action('create_payment', {
    amount: 1000,
    currency: 'usd',
});
```

## Best Practices

### 1. Keep Functions Small

```rust
// Good: One function, one purpose
#[forge::query]
pub async fn get_user_tasks(ctx: &QueryContext, user_id: Uuid) -> Result<Vec<Task>> { ... }

// Avoid: One function doing many things
#[forge::query]
pub async fn get_user_dashboard(ctx: &QueryContext, user_id: Uuid) -> Result<Dashboard> {
    // Fetches user, tasks, notifications, settings, stats...
}
```

### 2. Use Mutations for Side Effects

```rust
// Good: Mutation for data changes
#[forge::mutation]
pub async fn complete_task(ctx: &MutationContext, id: Uuid) -> Result<Task> { ... }

// Bad: Query that modifies data (don't do this!)
#[forge::query]
pub async fn complete_task(ctx: &QueryContext, id: Uuid) -> Result<Task> { ... }
```

### 3. Use Actions for External Calls

```rust
// Good: Action for external API
#[forge::action]
pub async fn send_sms(ctx: &ActionContext, phone: String, message: String) -> Result<()> { ... }

// Bad: External call in mutation (blocks transaction)
#[forge::mutation]
pub async fn verify_phone(ctx: &MutationContext, phone: String) -> Result<()> {
    // Don't call external APIs in mutations!
    send_sms_api(&phone).await?;
}
```

## What's Next?

<div className="row">
  <div className="col col--6">
    <a className="card" href="/concepts/realtime">
      <div className="card__header">
        <h3>âš¡ Real-Time</h3>
      </div>
      <div className="card__body">
        Live data subscriptions
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a className="card" href="/background/jobs">
      <div className="card__header">
        <h3>ðŸ“‹ Background Jobs</h3>
      </div>
      <div className="card__body">
        Process work in the background
      </div>
    </a>
  </div>
</div>
